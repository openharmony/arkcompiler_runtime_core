# plugin ets_string
# Copyright (c) 2024-2026 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

include_relative '../../plugins/ets/irtoc_scripts/common.irt'

module Constants
  MEM_BLOCK_8_BYTES = "8"
  MEM_BLOCK_8_ALIGN_CHECK_MASK = "8ULL - 1ULL"
  MEM_BLOCK_16_BYTES = "16"
  MEM_BLOCK_32_BYTES = "32"
  MEM_BLOCK_32_ALIGN_MASK = "~31ULL"
  LOG2_BITS_PER_U8 = "3"
  LOG2_BITS_PER_U16 = "4"
  LOG2_BYTES_PER_U16 = "1"
  XOR_SUB_U8_MASK = "0x0101010101010101ULL"
  XOR_AND_U8_MASK = "0x8080808080808080ULL"
  SINGLE_U8_MASK = "0xFFULL"
  MAX_U8_VALUE = "255"
  U8_SIZE = "1"
  U16_SIZE = "2"
  ADDR_16_BYTE_ALIGNED_MASK = "0x0FULL"
  WRONG_CHAR_FLAG_MASK = "0x10000UL"
  ASCII_CHAR_CACHE_SIZE = "cross_values::GetPlatformTypesAsciiCharCacheSize(GetArch())"
  STRING_PACKED_LENGTH_ZERO = "(((uint32_t)0xFFFFFFFF) << common::BaseString::STRING_LENGTH_BITS_NUM) >> common::BaseString::STRING_LENGTH_BITS_NUM"
  CHAR_FLIP_CASE_BIT = "1 << 5"
end

# It is assumed that _begin_index is safe and does not check/normalize them.
# The range is [_begin_index, _begin_index + _char_count).
# Note, a caller of this macro must provide a corresponding 'SlowPathEntrypoint'
# for the case when 'allocate_string_tlab' fails (see StringTrim as an example)
# Now TLAB implementation initializes memory with zero, so the hashcode field
# is not initialized with zero explicitly.
macro(:fast_substring) do |_str, _str_len, _begin_index, _char_count, _uncompressed, _cgmode|
  If(_char_count, Cast(_str_len).u32).EQ.Unlikely.b {
    # Return the string itself
    _same_str := Cast(_str).SrcType(Constants::COMPILER_REFERENCE).ptr
    Goto(:_Fast_Substring_Result_No_Barrier)
  }
  _klass := load_core_string_class()
  If(_char_count, 0).EQ.Unlikely.b {
    # Allocate and return an empty string
    _empty_str := allocate_string_tlab(_klass, 0, _cgmode)
    Goto(:_Fast_Substring_Result)
  }
  # Allocate a new normal string
  _offset := Shl(_begin_index, _uncompressed).u32
  _src_str_data := Add(Cast(_str).SrcType(Constants::COMPILER_REFERENCE).ptr, Cast(Constants::STRING_DATA_OFFSET).u64).ptr
  _src_str_data := Add(_src_str_data, Cast(_offset).u64).ptr
  If(_uncompressed, 1).EQ.Unlikely.b {
    _compressable := is_array_of_compressable_chars(_src_str_data, Cast(_char_count).u64)
    If(_compressable, 1).EQ.Likely.b {
      _data_size1 := Cast(_char_count).word
      Goto(:_L1)
    }
    _data_size2 := Cast(ShlI(_char_count).Imm(1).u32).word
Label(:_L1)
    _data_size := Phi(_data_size1, _data_size2).word
    _new_str1 := allocate_string_tlab(_klass, _data_size, _cgmode)
    _new_str_data := Add(_new_str1, Cast(Constants::STRING_DATA_OFFSET).u64).ptr
    If(_compressable, 1).EQ.Likely.b {
      compress_u16_to_u8_chars(_src_str_data, _new_str_data, Cast(_char_count).u64)
      StoreI(_new_str1, ShlI(_char_count).Imm(Constants::STRING_LENGTH_SHIFT).u32).Imm(Constants::STRING_LENGTH_OFFSET).u32
      Goto(:_Fast_Substring_Result)
    }
    copy_u16_chars(_src_str_data, _new_str_data, Cast(_char_count).u64)
    StoreI(_new_str1, OrI(ShlI(_char_count).Imm(Constants::STRING_LENGTH_SHIFT).u32).Imm(1).u32).Imm(Constants::STRING_LENGTH_OFFSET).u32
    Goto(:_Fast_Substring_Result)
  }
  # Source string is already compressed
  _new_str2 := allocate_string_tlab(_klass, Cast(_char_count).word, _cgmode)
  _new_str_data2 := Add(_new_str2, Cast(Constants::STRING_DATA_OFFSET).u64).ptr
  copy_u8_chars(_src_str_data, _new_str_data2, Cast(_char_count).u64)
  StoreI(_new_str2, ShlI(_char_count).Imm(Constants::STRING_LENGTH_SHIFT).u32).Imm(Constants::STRING_LENGTH_OFFSET).u32
Label(:_Fast_Substring_Result)
  # String is supposed to be a constant object, so all its data should be visible by all threads
  Intrinsic(:DATA_MEMORY_BARRIER_FULL).void
  _substring := Phi(_empty_str, _new_str1, _new_str1, _new_str2).ptr
Label(:_Fast_Substring_Result_No_Barrier)
  _result := Phi(_same_str, _substring).ptr
end


#
# Test if u16 char is a white space
#
scoped_macro(:is_white_space_u16) do |ch|
  IfImm(Compare(ch, 0x0020).EQ.b).Imm(0).NE.b {
    Goto(:LabelWhiteSpaceChar)
  }
  # 0x000E..0x009F -- common non-whitespace chars
  IfImm(Compare(ch, 0x000E).AE.b).Imm(0).NE.b {
    IfImm(Compare(ch, 0x00A0).B.b).Imm(0).NE.b {
      Goto(:LabelNotWhiteSpaceChar)
    }
  }
  # 0x0009 -- horizontal tab
  # 0x000A -- line feed or new line
  # 0x000B -- vertical tab
  # 0x000C -- formfeed
  # 0x000D -- carriage return
  IfImm(Compare(ch, 0x0009).B.b).Imm(0).NE.b {
    Goto(:LabelNotWhiteSpaceChar)
  }
  IfImm(Compare(ch, 0x000D).BE.b).Imm(0).NE.b {
    Goto(:LabelWhiteSpaceChar)
  }
  # 0x00A0 -- non-breaking space
  IfImm(Compare(ch, 0x00A0).EQ.b).Imm(0).NE.b {
    Goto(:LabelWhiteSpaceChar)
  }
  # 0x1680 -- Ogham space mark
  If(ch, 0x1680).EQ.Unlikely.b {
    Goto(:LabelWhiteSpaceChar)
  }
  # 0x2000 -- en quad
  # 0x2001 -- em quad
  # 0x2002 -- en space
  # 0x2003 -- em space
  # 0x2004 -- three-per-em space
  # 0x2005 -- four-per-em space
  # 0x2006 -- six-per-em space
  # 0x2007 -- figure space
  # 0x2008 -- punctuation space
  # 0x2009 -- thin space
  # 0x200A -- hair space
  If(ch, 0x2000).B.Unlikely.b {
    Goto(:LabelNotWhiteSpaceChar)
  }
  If(ch, 0x200A).BE.Unlikely.b {
    Goto(:LabelWhiteSpaceChar)
  }
  # 0x2028 -- line separator
  If(ch, 0x2028).EQ.Unlikely.b {
    Goto(:LabelWhiteSpaceChar)
  }
  # 0x2029 -- paragraph separator
  If(ch, 0x2029).EQ.Unlikely.b {
    Goto(:LabelWhiteSpaceChar)
  }
  # 0x202F -- narrow no-break space
  If(ch, 0x202F).EQ.Unlikely.b {
    Goto(:LabelWhiteSpaceChar)
  }
  # 0x205F -- medium mathematical space
  If(ch, 0x205F).EQ.Unlikely.b {
    Goto(:LabelWhiteSpaceChar)
  }
  # 0xFEFF -- byte order mark
  If(ch, 0xFEFF).EQ.Unlikely.b {
    Goto(:LabelWhiteSpaceChar)
  }
  # 0x3000 -- ideographic space
  If(ch, 0x3000).EQ.Unlikely.b {
    Goto(:LabelWhiteSpaceChar)
  }
Label(:LabelNotWhiteSpaceChar)
  whiteSpace0 := 0
  Goto(:LabelReturn)
Label(:LabelWhiteSpaceChar)
  whiteSpace1 := 1
Label(:LabelReturn)
  result := Phi(whiteSpace0, whiteSpace1).b
end

#
# Test if u8 char is a white space
#
scoped_macro(:is_white_space_u8) do |ch|
  IfImm(Compare(ch, 0x20).EQ.b).Imm(0).NE.b {
    Goto(:LabelWhiteSpaceChar)
  }
  # 0x0E..0x9F -- common non-whitespace chars
  IfImm(Compare(ch, 0x0E).AE.b).Imm(0).NE.b {
    IfImm(Compare(ch, 0xA0).B.b).Imm(0).NE.b {
      Goto(:LabelNotWhiteSpaceChar)
    }
  }
  # 0x09 -- horizontal tab
  # 0x0A -- line feed or new line
  # 0x0B -- vertical tab
  # 0x0C -- formfeed
  # 0x0D -- carriage return
  IfImm(Compare(ch, 0x09).B.b).Imm(0).NE.b {
    Goto(:LabelNotWhiteSpaceChar)
  }
  IfImm(Compare(ch, 0x0D).BE.b).Imm(0).NE.b {
    Goto(:LabelWhiteSpaceChar)
  }
  # 0xA0 -- non-breaking space
  IfImm(Compare(ch, 0xA0).EQ.b).Imm(0).NE.b {
    Goto(:LabelWhiteSpaceChar)
  }
Label(:LabelNotWhiteSpaceChar)
  whiteSpace0 := 0
  Goto(:LabelReturn)
Label(:LabelWhiteSpaceChar)
  whiteSpace1 := 1
Label(:LabelReturn)
  result := Phi(whiteSpace0, whiteSpace1).b
end


function(:CharIsWhiteSpace,
          params: {ch: 'u16'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPathPlus]) {

  if Options.arch == :arm32
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end
  Return(is_white_space_u16(ch)).b
}

GenerateStringEquals(lang='Ets', dynamic=false, :FastPath)
GenerateStringEquals(lang='Ets', dynamic=false, :NativePlus)

function(:StringEmpty,
          params: {str: 'ref'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPath]) {

  if Options.arch == :arm32
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  empty_str := allocate_string_tlab(load_core_string_class(), 0, :FastPath)
  # String is supposed to be a constant object, so all its data should be visible by all threads
  Intrinsic(:DATA_MEMORY_BARRIER_FULL).void
  Return(empty_str).ptr
Label(:SlowPathEntrypoint)
  entrypoint = get_entrypoint_offset("CREATE_EMPTY_STRING_SLOW_PATH")
  Intrinsic(:SLOW_PATH_ENTRY).AddImm(entrypoint).MethodAsImm("CreateEmptyString1ArgBridge").Terminator.ptr
  Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
}


def GenerateStringTrimLeftBase(cgmode)
  function("StringTrimLeftBase#{(cgmode == :FastPath ? '' : 'NativePlus')}".to_sym,
          params: {str: 'ref', unused1: 'i32', unused2: 'i32'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [cgmode]) {

  if Options.arch == :arm32
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  length_packed := LoadI(str).Imm(Constants::STRING_LENGTH_OFFSET).u32
  str_data := Add(Cast(str).SrcType(Constants::COMPILER_REFERENCE).ptr, Cast(Constants::STRING_DATA_OFFSET).word).ptr
  uncompressed := is_string_uncompressed_u32(length_packed)
  length := ShrI(length_packed).Imm(Constants::STRING_LENGTH_SHIFT).i32
  start_index := Cast(1).i32
  If(uncompressed, 0).EQ.Likely.b {
    # String contains 8-bit chars
Label(:Loop1)
    i := Phi(start_index, i1).i32
    ws1 := is_white_space_u8(Load(str_data, i).u8)
    If(ws1, 0).NE.Likely.b {
      i1 := AddI(i).Imm(1).i32
      If(i1, length).LT.Likely.b {
        Goto(:Loop1)
      }
    }
    index1 := Phi(i, i1).i32
    Goto(:TrimLeft)
  }
  # String contains 16-bit chars
Label(:Loop2)
  j := Phi(start_index, j1).i32
  ws2 := is_white_space_u16(Load(str_data, ShlI(j).Imm(1).i32).u16)
  If(ws2, 0).NE.Likely.b {
    j1 := AddI(j).Imm(1).i32
    If(j1, length).LT.Likely.b {
      Goto(:Loop2)
    }
  }
  index2 := Phi(j, j1).i32
Label(:TrimLeft)
  index := Phi(index1, index2).i32
  char_count := Sub(length, index).u32
  trimmed := fast_substring(str, length, index, char_count, uncompressed, cgmode)
  Return(trimmed).ptr
Label(:SlowPathEntrypoint)
  if cgmode == :NativePlus
    Return(Call(str, index, length).Method('SubStringFromStringEntrypoint').ptr).ptr
  else
    entrypoint = get_entrypoint_offset("SUB_STRING_FROM_STRING_SLOW_PATH")
    Intrinsic(:SLOW_PATH_ENTRY, str, index, length).AddImm(entrypoint).MethodAsImm("SubStringFromStringOddSavedBridge").Terminator.ptr
    Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
  end
}
end
GenerateStringTrimLeftBase(:FastPath)
GenerateStringTrimLeftBase(:NativePlus)

def GenerateStringTrimLeft(cgmode)
  function("StringTrimLeft#{(cgmode == :FastPath ? '' : 'NativePlus')}".to_sym,
            params: {str_orig: 'ref', unused1: 'i32', unused2: 'i32'},
            regmap: $full_regmap,
            regalloc_set: $panda_mask,
            mode: [cgmode]) {

  if Options.arch == :arm32
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  if cgmode == :NativePlus
    str := try_use_cached_flat_str_reject_sliced(str_orig, AsGlobalLabel(:SlowPathEntrypoint))
  else
    check_not_tree_string_type(str) if defines.DEBUG
    # it still can be slice
    check_string_type(str_orig, AsGlobalLabel(:SlowPathEntrypoint))
    str := str_orig
  end

  length_packed := LoadI(str).Imm(Constants::STRING_LENGTH_OFFSET).u32
  If(length_packed, 1).LE.Unlikely.b {
    Return(Cast(str).SrcType(Constants::COMPILER_REFERENCE).ptr).ptr
  }
  str_data := Add(Cast(str).SrcType(Constants::COMPILER_REFERENCE).ptr, Cast(Constants::STRING_DATA_OFFSET).word).ptr
  uncompressed := is_string_uncompressed_u32(length_packed)
  If(uncompressed, 0).EQ.Likely.b {
    ws1 := is_white_space_u8(Load(str_data, 0).u8)
    Goto(:L1)
  }
  ws2 := is_white_space_u16(Load(str_data, 0).u16)
Label(:L1)
  ws := Phi(ws1, ws2).b
  If(ws, 0).EQ.Likely.b {
    Return(Cast(str).SrcType(Constants::COMPILER_REFERENCE).ptr).ptr
  }
  If(ShrI(length_packed).Imm(Constants::STRING_LENGTH_SHIFT).i32, 1).EQ.Unlikely.b {
    LiveOut(str).DstReg(regmap[:arg0]).ref
    entrypoint1 = get_entrypoint_offset("STRING_EMPTY")
    Intrinsic(:TAIL_CALL).AddImm(entrypoint1).MethodAsImm("StringEmpty").Terminator.ptr
  }

  # NativePlus is not handled by LLVM backend right now, so, passing
  # fake parameters to match the function signature is not required
  if cgmode == :NativePlus
    LiveOut(str).DstReg(regmap[:arg1]).ref
    entrypoint2 = get_entrypoint_offset("STRING_TRIM_LEFT_BASE_NATIVE_PLUS")
    Intrinsic(:TAIL_CALL).AddImm(entrypoint2).MethodAsImm("StringTrimLeftBaseNativePlus").Terminator.ptr
  else
    LiveOut(str).DstReg(regmap[:arg0]).ref
    LiveOut(unused1).DstReg(regmap[:arg1]).i32
    LiveOut(unused2).DstReg(regmap[:arg2]).i32
    entrypoint2 = get_entrypoint_offset("STRING_TRIM_LEFT_BASE")
    Intrinsic(:TAIL_CALL).AddImm(entrypoint2).MethodAsImm("StringTrimLeftBase").Terminator.ptr
  end
LabelGlobal(:SlowPathEntrypoint)
  if cgmode == :NativePlus
    Return(Call(str_orig).Method('StdCoreStringTrimLeft').ptr).ptr
  else
    entrypoint = get_entrypoint_offset("STRING_TRIM_LEFT_SLOW_PATH")
    Intrinsic(:SLOW_PATH_ENTRY, str_orig).AddImm(entrypoint).MethodAsImm("StringTrimLeft3ArgBridge").Terminator.ptr
    Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
  end
}
end
GenerateStringTrimLeft(:FastPath)
GenerateStringTrimLeft(:NativePlus)

def GenerateStringTrimRightBase(cgmode)
  function("StringTrimRightBase#{(cgmode == :FastPath ? '' : 'NativePlus')}".to_sym,
          params: {str: 'ref', unused1: 'i32', unused2: 'i32'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [cgmode]) {

  if Options.arch == :arm32
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  length_packed := LoadI(str).Imm(Constants::STRING_LENGTH_OFFSET).u32
  length := ShrI(length_packed).Imm(Constants::STRING_LENGTH_SHIFT).i32
  start_index := SubI(length).Imm(2).i32
  str_data := Add(Cast(str).SrcType(Constants::COMPILER_REFERENCE).ptr, Cast(Constants::STRING_DATA_OFFSET).word).ptr
  uncompressed := is_string_uncompressed_u32(length_packed)
  If(uncompressed, 0).EQ.Likely.b {
    # String contains 8-bit chars
Label(:Loop1)
    i := Phi(start_index, i1).i32
    ws1 := is_white_space_u8(Load(str_data, i).u8)
    If(ws1, 0).NE.Likely.b {
      i1 := SubI(i).Imm(1).i32
      If(i1, 0).GE.Likely.b {
        Goto(:Loop1)
      }
    }
    index1 := Phi(i, i1).i32
    Goto(:TrimRight)
  }
  # String contains 16-bit chars
Label(:Loop2)
  j := Phi(start_index, j1).i32
  ws2 := is_white_space_u16(Load(str_data, ShlI(j).Imm(1).i32).u16)
  If(ws2, 0).NE.Likely.b {
    j1 := SubI(j).Imm(1).i32
    If(j1, 0).GE.Likely.b {
      Goto(:Loop2)
    }
  }
  index2 := Phi(j, j1).i32
Label(:TrimRight)
  index := Phi(index1, index2).i32
  index := AddI(index).Imm(1).i32
  trimmed := fast_substring(str, length, 0, Cast(index).u32, uncompressed, cgmode)
  Return(trimmed).ptr
Label(:SlowPathEntrypoint)
  if cgmode == :NativePlus
    Return(Call(str, 0, index).Method('SubStringFromStringEntrypoint').ptr).ptr
  else
    entrypoint = get_entrypoint_offset("SUB_STRING_FROM_STRING_SLOW_PATH")
    Intrinsic(:SLOW_PATH_ENTRY, str, Cast(0).i32, index).AddImm(entrypoint).MethodAsImm("SubStringFromStringOddSavedBridge").Terminator.ptr
    Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
  end
}
end
GenerateStringTrimRightBase(:FastPath)
GenerateStringTrimRightBase(:NativePlus)

def GenerateStringTrimRight(cgmode)
  function("StringTrimRight#{(cgmode == :FastPath ? '' : 'NativePlus')}".to_sym,
          params: {str_orig: 'ref', unused1: 'i32', unused2: 'i32'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [cgmode]) {

  if Options.arch == :arm32
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  if cgmode == :NativePlus
    str := try_use_cached_flat_str_reject_sliced(str_orig, AsGlobalLabel(:SlowPathEntrypoint))
  else
    check_not_tree_string_type(str) if defines.DEBUG
    # it still can be slice
    check_string_type(str_orig, AsGlobalLabel(:SlowPathEntrypoint))
    str := str_orig
  end

  check_not_tree_string_type(str) if defines.DEBUG
  # it still can be slice
  check_string_type(str, AsGlobalLabel(:SlowPathEntrypoint))

  length_packed := LoadI(str).Imm(Constants::STRING_LENGTH_OFFSET).u32
  If(length_packed, 1).LE.Unlikely.b {
    Return(Cast(str).SrcType(Constants::COMPILER_REFERENCE).ptr).ptr
  }
  str_data := Add(Cast(str).SrcType(Constants::COMPILER_REFERENCE).ptr, Cast(Constants::STRING_DATA_OFFSET).word).ptr
  uncompressed := is_string_uncompressed_u32(length_packed)
  length := ShrI(length_packed).Imm(Constants::STRING_LENGTH_SHIFT).i32
  last_char_index :=  SubI(length).Imm(1).i32
  If(uncompressed, 0).EQ.Likely.b {
    ws1 := is_white_space_u8(Load(str_data, last_char_index).u8)
    Goto(:L1)
  }
  ws2 := is_white_space_u16(Load(str_data, ShlI(last_char_index).Imm(1).i32).u16)
Label(:L1)
  ws := Phi(ws1, ws2).b
  If(ws, 0).EQ.Likely.b {
    Return(Cast(str).SrcType(Constants::COMPILER_REFERENCE).ptr).ptr
  }
  If(length, 1).EQ.Unlikely.b {
    LiveOut(str).DstReg(regmap[:arg0]).ref
    entrypoint1 = get_entrypoint_offset('STRING_EMPTY')
    Intrinsic(:TAIL_CALL).AddImm(entrypoint1).MethodAsImm('StringEmpty').Terminator.ptr
  }

  if cgmode == :NativePlus
    LiveOut(str).DstReg(regmap[:arg1]).ref
    entrypoint2 = get_entrypoint_offset('STRING_TRIM_RIGHT_BASE_NATIVE_PLUS')
    Intrinsic(:TAIL_CALL).AddImm(entrypoint2).MethodAsImm('StringTrimRightBaseNativePlus').Terminator.ptr
  else
    LiveOut(str).DstReg(regmap[:arg0]).ref
    LiveOut(unused1).DstReg(regmap[:arg1]).i32
    LiveOut(unused2).DstReg(regmap[:arg2]).i32
    entrypoint2 = get_entrypoint_offset('STRING_TRIM_RIGHT_BASE')
    Intrinsic(:TAIL_CALL).AddImm(entrypoint2).MethodAsImm('StringTrimRightBase').Terminator.ptr
  end

LabelGlobal(:SlowPathEntrypoint)
  if cgmode == :NativePlus
    Return(Call(str_orig).Method('StdCoreStringTrimRight').ptr).ptr
  else
    entrypoint = get_entrypoint_offset('STRING_TRIM_RIGHT_SLOW_PATH')
    Intrinsic(:SLOW_PATH_ENTRY, str_orig).AddImm(entrypoint).MethodAsImm('StringTrimRight3ArgBridge').Terminator.ptr
    Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
  end
}
end
GenerateStringTrimRight(:FastPath)
GenerateStringTrimRight(:NativePlus)


def GenerateStringTrimBase(cgmode)
  function("StringTrimBase#{(cgmode == :FastPath ? '' : 'NativePlus')}".to_sym,
          params: {str: 'ref', unused1: 'i32', unused2: 'i32'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [cgmode]) {

  if Options.arch == :arm32
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  length_packed := LoadI(str).Imm(Constants::STRING_LENGTH_OFFSET).u32
  length := ShrI(length_packed).Imm(Constants::STRING_LENGTH_SHIFT).i32
  left := 0
  right := SubI(length).Imm(2).i32
  str_data := Add(Cast(str).SrcType(Constants::COMPILER_REFERENCE).ptr, Cast(Constants::STRING_DATA_OFFSET).word).ptr
  uncompressed := is_string_uncompressed_u32(length_packed)
  If(uncompressed, 0).EQ.Likely.b {
    # String contains 8-bit chars
Label(:Loop1)  # while (utf::IsWhiteSpaceChar(str->At(right)))
    right1 := Phi(right, right2).i32
    If(is_white_space_u8(Load(str_data, right1).u8), 0).NE.Likely.b {
      If(right1, 0).EQ.Unlikely.b {
        Goto(:Trim)
      }
      right2 := SubI(right1).Imm(1).i32
      Goto(:Loop1)
    }
Label(:Loop2)  # while (left < right && utf::IsWhiteSpaceChar(str->At(left)))
    left1 := Phi(left, left2).i32
    If(left1, right1).LT.Unlikely.b {
      If(is_white_space_u8(Load(str_data, left1).u8), 0).NE.Likely.b {
        left2 := AddI(left1).Imm(1).i32
        Goto(:Loop2)
      }
    }
    right3 := AddI(right1).Imm(1).i32
    Goto(:Trim)
  }
  # String contains 16-bit chars
Label(:Loop3)  # while (utf::IsWhiteSpaceChar(str->At(right)))
  right11 := Phi(right, right22).i32
  If(is_white_space_u16(Load(str_data, ShlI(right11).Imm(1).i32).u16), 0).NE.Likely.b {
    If(right11, 0).EQ.Unlikely.b {
      Goto(:Trim)
    }
    right22 := SubI(right11).Imm(1).i32
    Goto(:Loop3)
  }
Label(:Loop4)  # while (left < right && utf::IsWhiteSpaceChar(str->At(left)))
  left11 := Phi(left, left22).i32
  If(left11, right11).LT.Unlikely.b {
    If(is_white_space_u16(Load(str_data, ShlI(left11).Imm(1).i32).u16), 0).NE.Likely.b {
      left22 := AddI(left11).Imm(1).i32
      Goto(:Loop4)
    }
  }
  right33 := AddI(right11).Imm(1).i32
Label(:Trim)
  l := Phi(left, left1, left, left11).i32
  r := Phi(right1, right3, right11, right33).i32
  char_count := Sub(r, l).u32
  trimmed := fast_substring(str, length, l, char_count, uncompressed, cgmode)
  Return(trimmed).ptr
Label(:SlowPathEntrypoint)
  if cgmode == :NativePlus
    Return(Call(str, l, r).Method('SubStringFromStringEntrypoint').ptr).ptr
  else
    entrypoint = get_entrypoint_offset('SUB_STRING_FROM_STRING_SLOW_PATH')
    Intrinsic(:SLOW_PATH_ENTRY, str, l, r).AddImm(entrypoint).MethodAsImm('SubStringFromStringOddSavedBridge').Terminator.ptr
    Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
  end
}
end
GenerateStringTrimBase(:FastPath)
GenerateStringTrimBase(:NativePlus)

def GenerateStringTrim(cgmode)
  function("StringTrim#{(cgmode == :FastPath ? '' : 'NativePlus')}".to_sym,
          params: {str_orig: 'ref', unused1: 'i32', unused2: 'i32'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [cgmode]) {

  if Options.arch == :arm32
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  if cgmode == :NativePlus
    str := try_use_cached_flat_str_reject_sliced(str_orig, AsGlobalLabel(:SlowPathEntrypoint))
  else
    check_not_tree_string_type(str) if defines.DEBUG
    # it still can be slice
    check_string_type(str_orig, AsGlobalLabel(:SlowPathEntrypoint))
    str := str_orig
  end

  length_packed := LoadI(str).Imm(Constants::STRING_LENGTH_OFFSET).u32
  # length == 0
  If(length_packed, 1).LE.Unlikely.b {
    Return(Cast(str).SrcType(Constants::COMPILER_REFERENCE).ptr).ptr
  }
  str_data := Add(Cast(str).SrcType(Constants::COMPILER_REFERENCE).ptr, Cast(Constants::STRING_DATA_OFFSET).word).ptr
  uncompressed := is_string_uncompressed_u32(length_packed)
  length := ShrI(length_packed).Imm(Constants::STRING_LENGTH_SHIFT).i32
  # length == 1
  If(length, 1).EQ.b {
    If(uncompressed, 0).EQ.Likely.b {
      ws1 := is_white_space_u8(Load(str_data, 0).u8)
      Goto(:L1)
    }
    ws2 := is_white_space_u16(Load(str_data, 0).u16)
Label(:L1)
    ws3 := Phi(ws1, ws2).b
    If(ws3, 0).EQ.Likely.b {
      Return(Cast(str).SrcType(Constants::COMPILER_REFERENCE).ptr).ptr
    }
    LiveOut(str).DstReg(regmap[:arg0]).ref
    entrypoint1 = get_entrypoint_offset("STRING_EMPTY")
    Intrinsic(:TAIL_CALL).AddImm(entrypoint1).MethodAsImm("StringEmpty").Terminator.ptr
  }
  # length > 1
  last_char_index := SubI(length).Imm(1).i32
  If(uncompressed, 0).EQ.Likely.b {
    ws4 := is_white_space_u8(Load(str_data, last_char_index).u8)
    Goto(:L2)
  }
  ws5 := is_white_space_u16(Load(str_data, ShlI(last_char_index).Imm(1).i32).u16)
Label(:L2)
  ws6 := Phi(ws4, ws5).b
  If(ws6, 0).EQ.Likely.b {
    # last char is not whitespace, so check the first char
    If(uncompressed, 0).EQ.Likely.b {
      ws7 := is_white_space_u8(Load(str_data, 0).u8)
      Goto(:L3)
    }
    ws8 := is_white_space_u16(Load(str_data, 0).u16)
Label(:L3)
    ws9 := Phi(ws7, ws8).b
    If(ws9, 0).EQ.Likely.b {
      # first char is not white space, so return 'str'
      Return(Cast(str).SrcType(Constants::COMPILER_REFERENCE).ptr).ptr
    }
    Goto(:FirstCharWhitespace)
  }
  # last char is whitespace, so call StringTrimBase
  if cgmode == :NativePlus
    LiveOut(str).DstReg(regmap[:arg1]).ref
    entrypoint2 = get_entrypoint_offset('STRING_TRIM_BASE_NATIVE_PLUS')
    Intrinsic(:TAIL_CALL).AddImm(entrypoint2).MethodAsImm('StringTrimBaseNativePlus').Terminator.ptr
  else
    LiveOut(str).DstReg(regmap[:arg0]).ref
    LiveOut(unused1).DstReg(regmap[:arg1]).i32
    LiveOut(unused2).DstReg(regmap[:arg2]).i32
    entrypoint2 = get_entrypoint_offset('STRING_TRIM_BASE')
    Intrinsic(:TAIL_CALL).AddImm(entrypoint2).MethodAsImm('StringTrimBase').Terminator.ptr
  end
  Label(:FirstCharWhitespace)
  if cgmode == :NativePlus
    LiveOut(str).DstReg(regmap[:arg1]).ref
    entrypoint3 = get_entrypoint_offset("STRING_TRIM_LEFT_BASE_NATIVE_PLUS")
    Intrinsic(:TAIL_CALL).AddImm(entrypoint3).MethodAsImm("StringTrimLeftBaseNativePlus").Terminator.ptr
  else
    LiveOut(str).DstReg(regmap[:arg0]).ref
    LiveOut(unused1).DstReg(regmap[:arg1]).i32
    LiveOut(unused2).DstReg(regmap[:arg2]).i32
    entrypoint3 = get_entrypoint_offset("STRING_TRIM_LEFT_BASE")
    Intrinsic(:TAIL_CALL).AddImm(entrypoint3).MethodAsImm("StringTrimLeftBase").Terminator.ptr
  end
  LabelGlobal(:SlowPathEntrypoint)
  if cgmode == :NativePlus
    Return(Call(str_orig).Method('StdCoreStringTrim').ptr).ptr
  else
    entrypoint = get_entrypoint_offset("STRING_TRIM_SLOW_PATH")
    Intrinsic(:SLOW_PATH_ENTRY, str_orig).AddImm(entrypoint).MethodAsImm("StringTrim3ArgBridge").Terminator.ptr
    Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
  end
}
end
GenerateStringTrim(:FastPath)
GenerateStringTrim(:NativePlus)


scoped_macro(:at) do |str_data, index, uncompressed|
  If(uncompressed, 0).EQ.Likely.b {
    # String contains 8-bit chars
    c8 := Cast(Load(str_data, index).u8).u16
    Goto(:Done)
  }
  # String contains 16-bit chars
  c16 := Load(str_data, ShlI(index).Imm(1).i32).u16
Label(:Done)
  c := Phi(c8, c16).u16
end


function(:StringStartsWithBase,
          params: {str: 'ref', pfx: 'ref', from_index: 'i32', pfx_i1: 'i32'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPathPlus]) {

  if Options.arch == :arm32
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  str_len_packed := LoadI(str).Imm(Constants::STRING_LENGTH_OFFSET).u32
  str_uncompressed := is_string_uncompressed_u32(str_len_packed)
  str_data := Add(Cast(str).SrcType(Constants::COMPILER_REFERENCE).ptr, Cast(Constants::STRING_DATA_OFFSET).word).ptr
  pfx_len_packed := LoadI(pfx).Imm(Constants::STRING_LENGTH_OFFSET).u32
  pfx_len := ShrI(pfx_len_packed).Imm(Constants::STRING_LENGTH_SHIFT).i32
  pfx_uncompressed := is_string_uncompressed_u32(pfx_len_packed)
  pfx_data := Add(Cast(pfx).SrcType(Constants::COMPILER_REFERENCE).ptr, Cast(Constants::STRING_DATA_OFFSET).word).ptr

Label(:Loop)
  str_i := Phi(from_index, str_i1).i32
  pfx_i := Phi(pfx_i1, pfx_i2).i32
  If(pfx_i, pfx_len).GE.Unlikely.b {
    Goto(:Done)
  }
  s := at(str_data, str_i, str_uncompressed)
  p := at(pfx_data, pfx_i, pfx_uncompressed)
  If(s, p).NE.Likely.b {
    Return(0).b
  }
  pfx_i2 := AddI(pfx_i).Imm(1).i32
  str_i1 := AddI(str_i).Imm(1).i32
  Goto(:Loop)
Label(:Done)
  Return(1).b
}

def GenerateStringStartsWith(cgmode)
  suffix = (cgmode == :NativePlus ? 'NativePlus': '')
  upsuffix = (cgmode == :NativePlus ? '_NATIVE_PLUS': '')
  function("StringStartsWith#{suffix}".to_sym,
           params: {str_orig: 'ref', pfx_orig: 'ref', from_index: 'i32', arg4: 'i32'},
           regmap: $full_regmap,
           regalloc_set: $panda_mask,
           mode: [cgmode]) {

  if Options.arch == :arm32
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  if cgmode == :NativePlus
    str_orig0 := try_use_cached_flat_str_accept_sliced(str_orig, AsGlobalLabel(:SlowPathEntrypoint))
    pfx_orig0 := try_use_cached_flat_str_accept_sliced(pfx_orig, AsGlobalLabel(:SlowPathEntrypoint))
  else
    check_not_tree_string_type(str_orig) if defines.DEBUG
    check_not_tree_string_type(pfx_orig) if defines.DEBUG
    str_orig0 := str_orig
    pfx_orig0 := pfx_orig
  end

  strBaseClass := load_class(str_orig0)
  strType := LoadI(strBaseClass).Imm(Constants::STRING_TYPE_OFFSET).u64

  zeroIndex := Cast(0).u32

  If(strType, Constants::STRING_TYPE_SLICE).EQ {
    strParent := LoadI(str_orig0).Imm(Constants::SLICED_STRING_PARENT_OFFSET).SetNeedBarrier(true).ref
    strStartIndexAndBits := LoadI(str_orig0).Imm(Constants::SLICED_STRING_STARTINDEX_AND_FLAGS_OFFSET).u32
    strStartIndex := ShrI(strStartIndexAndBits).Imm(Constants::SLICED_STRING_STARTINDEX_SHIFT).u32
  }

  str := Phi(str_orig0, strParent).ref
  resultStrStartIndex := Phi(zeroIndex, strStartIndex).u32

  pfxBaseClass := load_class(pfx_orig0)
  pfxType := LoadI(pfxBaseClass).Imm(Constants::STRING_TYPE_OFFSET).u64

  If(pfxType, Constants::STRING_TYPE_SLICE).EQ {
    pfxParent := LoadI(pfx_orig0).Imm(Constants::SLICED_STRING_PARENT_OFFSET).SetNeedBarrier(true).ref
    pfxStartIndexAndBits := LoadI(pfx_orig0).Imm(Constants::SLICED_STRING_STARTINDEX_AND_FLAGS_OFFSET).u32
    pfxStartIndex := ShrI(pfxStartIndexAndBits).Imm(Constants::SLICED_STRING_STARTINDEX_SHIFT).u32
  }

  pfx := Phi(pfx_orig0, pfxParent).ref
  resultPfxStartIndex := Phi(zeroIndex, pfxStartIndex).u32

  pfx_len_packed := LoadI(pfx_orig).Imm(Constants::STRING_LENGTH_OFFSET).u32
  # Return 'true' if prefix is empty
  # The least significant bit indicates COMPRESSED/UNCOMPRESSED,
  # thus if (packed length <= 1) then the actual length is equal to 0.
  If(pfx_len_packed, 1).LE.Unlikely.b {
    Return(1).b
  }

  str_len_packed := LoadI(str_orig).Imm(Constants::STRING_LENGTH_OFFSET).u32
  # Return 'false' if 'str' is empty as 'prefix' is not empty.
  If(str_len_packed, 1).LE.Unlikely.b {
    Return(0).b
  }

  # If 'from_index' is less than zero then make it zero.
  IfImm(Compare(from_index, 0).LT.b).Imm(0).NE.Unlikely.b {
    from_index1 := Cast(0).i32
  }
  from_index2 := Phi(from_index, from_index1).i32

  str_len := ShrI(str_len_packed).Imm(Constants::STRING_LENGTH_SHIFT).i32
  pfx_len := ShrI(pfx_len_packed).Imm(Constants::STRING_LENGTH_SHIFT).i32

  If(from_index2, Sub(str_len, pfx_len).i32).GT.Unlikely.b {
    # Return 'false' in this case, as we know that 'pfx' is not empty
    # and it is longer than the part of 'str' to be checked.
    Return(0).b
  }

  from_index3 := Add(from_index2, resultStrStartIndex).i32

  if cgmode == :NativePlus
    LiveOut(str).DstReg(regmap[:arg1]).ref
    LiveOut(pfx).DstReg(regmap[:arg2]).ref
    LiveOut(from_index3).DstReg(regmap[:arg3]).i32
    LiveOut(resultPfxStartIndex).DstReg(regmap[:arg4]).i32
  else
    LiveOut(str).DstReg(regmap[:arg0]).ref
    LiveOut(pfx).DstReg(regmap[:arg1]).ref
    LiveOut(from_index3).DstReg(regmap[:arg2]).i32
    LiveOut(resultPfxStartIndex).DstReg(regmap[:arg3]).i32
  end
  entrypoint = get_entrypoint_offset("STRING_STARTS_WITH_BASE#{upsuffix}")
  Intrinsic(:TAIL_CALL).AddImm(entrypoint).MethodAsImm("StringStartsWithBase#{suffix}").Terminator.b

  if cgmode == :NativePlus
  LabelGlobal(:SlowPathEntrypoint)
    Return(Call(str_orig, pfx_orig, from_index).Method("StdCoreStringStartsWith").b).b
  end
}
end

GenerateStringStartsWith(:FastPath)
GenerateStringStartsWith(:NativePlus)


function(:StringEndsWithBase,
          params: {str: 'ref', sfx: 'ref', end_index: 'i32'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPathPlus]) {

  if Options.arch == :arm32
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  str_len_packed := LoadI(str).Imm(Constants::STRING_LENGTH_OFFSET).u32
  str_uncompressed := is_string_uncompressed_u32(str_len_packed)
  str_data := Add(Cast(str).SrcType(Constants::COMPILER_REFERENCE).ptr, Cast(Constants::STRING_DATA_OFFSET).word).ptr
  sfx_len_packed := LoadI(sfx).Imm(Constants::STRING_LENGTH_OFFSET).u32
  sfx_uncompressed := is_string_uncompressed_u32(sfx_len_packed)
  sfx_data := Add(Cast(sfx).SrcType(Constants::COMPILER_REFERENCE).ptr, Cast(Constants::STRING_DATA_OFFSET).word).ptr
  sfx_len := ShrI(sfx_len_packed).Imm(Constants::STRING_LENGTH_SHIFT).i32
  from_index := Sub(end_index, sfx_len).i32;

  sfx_i1 := 0
Label(:Loop)
  str_i := Phi(from_index, str_i1).i32
  sfx_i := Phi(sfx_i1, sfx_i2).i32
  If(sfx_i, sfx_len).GE.Unlikely.b {
    Goto(:Done)
  }
  s := at(str_data, str_i, str_uncompressed)
  p := at(sfx_data, sfx_i, sfx_uncompressed)
  If(s, p).NE.Likely.b {
    Return(0).b
  }
  sfx_i2 := AddI(sfx_i).Imm(1).i32
  str_i1 := AddI(str_i).Imm(1).i32
  Goto(:Loop)

Label(:Done)
  Return(1).b
}

def GenerateStringEndsWith(cgmode)
  suffix = (cgmode == :NativePlus ? 'NativePlus': '')
  upsuffix = (cgmode == :NativePlus ? '_NATIVE_PLUS': '')
  function("StringEndsWith#{suffix}".to_sym,
           params: {str_orig: 'ref', sfx_orig: 'ref', end_index: 'i32'},
           regmap: $full_regmap,
           regalloc_set: $panda_mask,
           mode: [cgmode]) {

  if Options.arch == :arm32
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  if cgmode == :NativePlus
    str := try_use_cached_flat_str_reject_sliced(str_orig, AsGlobalLabel(:SlowPathEntrypoint))
    sfx := try_use_cached_flat_str_reject_sliced(sfx_orig, AsGlobalLabel(:SlowPathEntrypoint))
  else
    check_not_tree_string_type(str_orig) if defines.DEBUG
    check_not_tree_string_type(sfx_orig) if defines.DEBUG
    # it still can be slice
    check_string_type(str_orig, AsGlobalLabel(:SlowPathEntrypoint))
    check_string_type(sfx_orig, AsGlobalLabel(:SlowPathEntrypoint))
    str := str_orig
    sfx := sfx_orig
  end

  sfx_len_packed := LoadI(sfx).Imm(Constants::STRING_LENGTH_OFFSET).u32
  # Return 'true' if suffix is empty
  # The least significant bit indicates COMPRESSED/UNCOMPRESSED,
  # thus if (packed length <= 1) then the actual length is equal to 0.
  If(sfx_len_packed, 1).LE.Unlikely.b {
    Return(1).b
  }

  str_len_packed := LoadI(str).Imm(Constants::STRING_LENGTH_OFFSET).u32
  # Return 'false' if 'str' is empty as 'suffix' is not empty.
  If(str_len_packed, 1).LE.Unlikely.b {
    Return(0).b
  }
  # If 'end_index' is less or equal to zero then return false.
  IfImm(Compare(end_index, 0).LE.b).Imm(0).NE.Unlikely.b {
    Return(0).b
  }

  str_len := ShrI(str_len_packed).Imm(Constants::STRING_LENGTH_SHIFT).i32
  # If 'end_index' is greater than length of 'str' make it equal to length of 'str'.
  If(end_index, str_len).GT.Unlikely.b {
    end_index1 := str_len
  }
  end_index2 := Phi(end_index, end_index1).i32

  sfx_len := ShrI(sfx_len_packed).Imm(Constants::STRING_LENGTH_SHIFT).i32
  from_index := Sub(end_index2, sfx_len).i32;
  IfImm(Compare(from_index, 0).LT.b).Imm(0).NE.Unlikely.b {
    # Return 'false' in this case, as 'sfx' length is greater than 'end_index'.
    Return(0).b
  }

  if cgmode == :NativePlus
    LiveOut(str).DstReg(regmap[:arg1]).ref
    LiveOut(sfx).DstReg(regmap[:arg2]).ref
    LiveOut(end_index2).DstReg(regmap[:arg3]).i32
  else
    LiveOut(str).DstReg(regmap[:arg0]).ref
    LiveOut(sfx).DstReg(regmap[:arg1]).ref
    LiveOut(end_index2).DstReg(regmap[:arg2]).i32
  end
  entrypoint = get_entrypoint_offset("STRING_ENDS_WITH_BASE#{upsuffix}")
  Intrinsic(:TAIL_CALL).AddImm(entrypoint).MethodAsImm("StringEndsWithBase#{suffix}").Terminator.b
LabelGlobal(:SlowPathEntrypoint)
  if cgmode == :NativePlus
    Return(Call(str_orig, sfx_orig, end_index).Method("StdCoreStringEndsWith").b).b
  else
    entrypoint = get_entrypoint_offset("STRING_ENDS_WITH_SLOW_PATH")
    Intrinsic(:SLOW_PATH_ENTRY, str_orig, sfx_orig, end_index).AddImm(entrypoint).MethodAsImm("StringEndsWithOddSavedBridge").Terminator.b
    Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
  end
}
end

GenerateStringEndsWith(:FastPath)
GenerateStringEndsWith(:NativePlus)

def GenerateStringGetBytesTlab(cgmode)
  function("StringGetBytesTlab#{(cgmode == :NativePlus ? 'NativePlus' : '')}".to_sym,
           params: {str_orig: 'ref', begin_index: 'i32', end_index: 'i32', array_klass: 'ref'},
           regmap: $full_regmap,
           regalloc_set: $panda_mask,
           mode: [cgmode]) {

  if Options.arch == :arm32
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  if cgmode == :NativePlus
    str := try_use_cached_flat_str_reject_sliced(str_orig, AsGlobalLabel(:SlowPathEntrypoint))
  else
    check_not_tree_string_type(str) if defines.DEBUG
    # it still can be slice
    check_string_type(str_orig, AsGlobalLabel(:SlowPathEntrypoint))
    str := str_orig
  end

  If(begin_index, end_index).GT.Unlikely.b {
    Goto(:SlowPathEntrypoint)  # Out of range
  }

  If(begin_index, Cast(0).i32).LT.Unlikely.b {
    Goto(:SlowPathEntrypoint)  # Out of range
  }

  # Note, 'str' is checked against nullptr in the InstBuilder (see AddArgNullcheckIfNeeded)
  length := LoadI(str).Imm(Constants::STRING_LENGTH_OFFSET).u32;
  uncompressed := is_string_uncompressed_u32(length);
  length := ShrI(length).Imm(Constants::STRING_LENGTH_SHIFT).u32;

  If(Cast(end_index).u32, length).A.Unlikely.b {
    Goto(:SlowPathEntrypoint)  # Out of range
  }
  offset := Shl(begin_index, uncompressed).u32

  src_str_data := Add(Cast(str).SrcType(Constants::COMPILER_REFERENCE).ptr, Cast(Constants::STRING_DATA_OFFSET).u64).ptr
  src_str_data := Add(src_str_data, Cast(offset).u64).ptr

  # Allocate a new array of u8 (bytes)
  count := Sub(Cast(end_index).u32, Cast(begin_index).u32).u64
  new_arr := allocate_array_of_bytes_tlab(array_klass, Cast(count).word, cgmode)
  new_arr_data := Add(new_arr, Cast(Constants::ARRAY_DATA_OFFSET).u64).ptr
  If(uncompressed, Cast(0).u32).EQ.Likely.b {
    copy_u8_chars(src_str_data, new_arr_data, count)
    Goto(:End)
  }
  compress_u16_to_u8_chars(src_str_data, new_arr_data, count)

  Label(:End)
  # Array data should be stored before publishing reference to array
  Intrinsic(:DATA_MEMORY_BARRIER_FULL).void
  Return(new_arr).ptr

  LabelGlobal(:SlowPathEntrypoint)
  if cgmode == :NativePlus
    Return(Call(str_orig, begin_index, end_index).Method('StdCoreStringGetBytes').ptr).ptr
  else
    entrypoint = get_entrypoint_offset("STRING_GET_BYTES_SLOW_PATH")
    Intrinsic(:SLOW_PATH_ENTRY, str_orig, begin_index, end_index).AddImm(entrypoint).MethodAsImm("StringGetBytes4ArgBridge").Terminator.ptr
    Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
  end
}
end

GenerateStringGetBytesTlab(:FastPath)
GenerateStringGetBytesTlab(:NativePlus)


###
# Char codes in an instance of 'std.core.Array' are represented as an array of object pointers to instances of the
# boxing class 'std.core.Double'. Runtime stores such objects as instances of the 'ark::ets::EtsBoxPrimitive' class
# and every instance has a field of type 'double', the value.
#
# The macro reads the boxed value by an object pointer and applies unboxing.
#
scoped_macro(:load_char_code) do |char_codes, offset|
  _boxed_ptr := get_object_pointer(char_codes, offset)
  _char_code := LoadI(_boxed_ptr).Imm(EtsConstants::BOX_PRIMITIVE_VALUE_OFFSET).f64
end  # load_char_code

###
# Tries to convert flag_char_pair, the result of calling the JS_CAST_DOUBLE_TO_CHAR intrinsic, into a Utf16 char (u16).
# The macro checks whether the conversion was successful: whether an overflow or underflow takes place during the
# conversion of a denormalized number and if so goes to the slow path.
#
scoped_macro(:validate_flag_char_pair) do |flag_char_pair|
  _convertible1 := Cast(1).b
  If(AndI(flag_char_pair).Imm(Constants::WRONG_CHAR_FLAG_MASK).u32, 0).NE.Unlikely {
    _convertible2 := Cast(0).b
  }
  _convertible := Phi(_convertible1, _convertible2).b
end  # validate_flag_char_pair

###
# Tries to convert a char_code into a Utf16 char (u16).
# The macro checks whether the conversion was successful: whether an overflow or underflow takes place during the
# conversion of a denormalized number and if so goes to the slow path.
#
scoped_macro(:validate_char_code) do |char_code|
  _flag_char_pair := Intrinsic(:JS_CAST_DOUBLE_TO_CHAR, char_code).u32
  _convertible := validate_flag_char_pair(_flag_char_pair)
end  # validate_char_code

###
# Checks if starting from codes_data the specified number of codes (codes_count) are convertible: whenever
# an overflow or underflow takes place during the conversion of a denormalized number we have to go to the
# slow path.
#
scoped_macro(:is_array_of_convertible_char_codes) do |codes_data, codes_count|
  if Options.jscvt_feature_enabled?
    _convertible := Cast(1).b
  else
    _offset1 := Cast(0).u64
    _codes_len := ShlI(codes_count).Imm(EtsConstants::OBJ_PTR_LOG2_SIZE).u64
    _convertible1 := Cast(1).b
Label(:Loop)
    _offset := Phi(_offset1, _offset2).u64
    If(_offset, _codes_len).AE.Unlikely {
      Goto(:LoopDone)
    }
    _convertible2 := validate_char_code(load_char_code(codes_data, _offset).f64)
    If(_convertible2, 0).EQ.Unlikely.b {
      Goto(:LoopDone)
    }
    _offset2 := AddI(_offset).Imm(EtsConstants::OBJ_PTR_SIZE).u64
    Goto(:Loop)
Label(:LoopDone)
    _convertible := Phi(_convertible1, _convertible2).b
  end
end # is_array_of_convertible_char_codes

###
# Converts a flag_char_pair, the result of calling the JS_CAST_DOUBLE_TO_CHAR intrinsic, into a Utf16 char (u16).
# Note, a caller of this macro must be sure the conversion will always be successful: neither overflow nor
# underflow will take place during the conversion of a denormalized number.
#
scoped_macro(:get_char_from_flag_char_pair) do |flag_char_pair|
  if !Options.jscvt_feature_enabled? and defines.DEBUG
    If(AndI(flag_char_pair).Imm(Constants::WRONG_CHAR_FLAG_MASK).u32, 0).NE.Unlikely {
      Intrinsic(:UNREACHABLE).Terminator.void
    }
  end
  _char := Cast(flag_char_pair).u16
end  # get_char_from_flag_char_pair

###
# Converts a char_code (f64) into a Utf16 char (u16).
# Note, a caller of this macro must be sure the conversion will always be successful: neither overflow nor
# underflow will take place during the conversion of a denormalized number.
#
scoped_macro(:get_char_from_code) do |char_code|
  _flag_char_pair := Intrinsic(:JS_CAST_DOUBLE_TO_CHAR, char_code).u32
  _char := get_char_from_flag_char_pair(_flag_char_pair)
end  # get_char_from_code

###
# Checks if starting from codes_data the specified number of codes (codes_count) represent
# an array of compressible chars
#
# Utf16 char is ASCII if (utf16_char - 1U < utf::UTF8_1B_MAX)
# See runtime/include/coretypes/string.h - IsASCIICharacter
#
scoped_macro(:is_array_of_compressible_char_codes) do |codes_data, codes_count|
  _offset1 := Cast(0).u64
  _codes_len := ShlI(codes_count).Imm(EtsConstants::OBJ_PTR_LOG2_SIZE).u64
  _compressible1 := Cast(1).b
Label(:Loop)
  _offset := Phi(_offset1, _offset2).u64
  If(_offset, _codes_len).AE.Unlikely {
    Goto(:LoopDone)
  }
  _char := get_char_from_code(load_char_code(codes_data, _offset).f64)
  If(SubI(_char).Imm(Constants::STRING_MUTF8_1B_MIN).u16, Cast(Constants::STRING_MUTF8_1B_MAX).u16).AE.Unlikely {
    _compressible2 := Cast(0).b
    Goto(:LoopDone)
  }
  _offset2 := AddI(_offset).Imm(EtsConstants::OBJ_PTR_SIZE).u64
  Goto(:Loop)

Label(:LoopDone)
  _compressible := Phi(_compressible1, _compressible2).b
end  # is_array_of_compressible_char_codes

###
# Converts char codes (numbers) to chars with type equals either to "u8" or "u16". For type equals to "u8", it is
# assumed that all char codes represent compressible chars.
#
["u8", "u16"].each do |type|
  scoped_macro("convert_char_codes_to_#{type}_chars".to_sym) do |src, dst, count|
    compressed_string = type == "u8"
    _i1 := Cast(0).u64
Label(:Loop)
    _i := Phi(_i1, _i2).u64
    If(_i, count).AE.Unlikely {
      Goto(:LoopDone)
    }
    _code_offset := ShlI(_i).Imm(EtsConstants::OBJ_PTR_LOG2_SIZE).u64
    _char := get_char_from_code(load_char_code(src, _code_offset).f64)
    if compressed_string
      _char_offset := Cast(_i).u64
      Store(dst, _char_offset, _char).u8
    else
      _char_offset := ShlI(_i).Imm(Constants::LOG2_BYTES_PER_U16).u64
      Store(dst, _char_offset, _char).u16
    end
    _i2 := AddI(_i).Imm(1).u64
    Goto(:Loop)

Label(:LoopDone)
  end  # convert_char_codes_to_#{type}_chars
end

###
# Reads a string formed from a one-byte char 'char' from the cache 'cache'
#
scoped_macro(:read_from_cache) do |cache, char|
  _string_offset := AddI(ShlI(Cast(char).u64).Imm(EtsConstants::OBJ_PTR_LOG2_SIZE).u64).Imm(Constants::ARRAY_DATA_OFFSET).u64
  get_object_pointer(cache, _string_offset)
end # read_from_cache

function(:CreateStringFromCharCodeTlab,
        params: {char_codes: 'ref', string_klass: 'ref'},
        regmap: $full_regmap,
        regalloc_set: $panda_mask,
        mode: [:FastPath]) {

  if Options.arch == :arm32
    Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
    ReturnVoid().void
    next
  end

  # There is no check of the arguments against NullPointer as
  # it's done in the InstBuilder (see AddArgNullcheckIfNeeded) for non-empty arrays
  # and we suppose that the `NewArray (size=0)` instruction never returns `null`.
  if defines.DEBUG
    If(char_codes, 0).EQ {
      Intrinsic(:UNREACHABLE).Terminator.void
    }
  end

  char_codes_array := get_object_pointer_imm(char_codes, EtsConstants::ESCOMPAT_ARRAY_DATA_OFFSET)
  codes_data := AddI(char_codes_array).Imm(Constants::ARRAY_DATA_OFFSET).ptr
  codes_count := LoadI(char_codes).Imm(EtsConstants::ESCOMPAT_ARRAY_ACTUAL_LENGTH_OFFSET).u32

  # Validate if all the char codes are convertible: whenever an overflow or underflow takes place during the
  # conversion of a denormalized number we have to go to the slow path. The validation must take place before
  # any attempts to allocate the memory in TLAB.
  convertible := is_array_of_convertible_char_codes(codes_data, Cast(codes_count).u64)
  If(convertible, 0).EQ.Unlikely {
    Goto(:SlowPathEntrypoint)
  }

  # Allocate a new string
  compressible := is_array_of_compressible_char_codes(codes_data, Cast(codes_count).u64)
  If(compressible, 1).EQ.Likely {
    data_size1 := Cast(codes_count).word
  } Else {
    data_size2 := Cast(ShlI(codes_count).Imm(Constants::LOG2_BYTES_PER_U16).u32).word
  }
  data_size := Phi(data_size1, data_size2).word
  new_str := allocate_string_tlab(string_klass, data_size, :FastPath)
  str_data := Add(new_str, Cast(Constants::STRING_DATA_OFFSET).u64).ptr

  # Copy data from char_codes to the new string with the required preprocessing
  # String length field is set according to SetLength() from runtime/include/coretypes/string.h
  If(compressible, 1).EQ.Likely {
    convert_char_codes_to_u8_chars(codes_data, str_data, Cast(codes_count).u64)
    StoreI(new_str, ShlI(codes_count).Imm(Constants::STRING_LENGTH_SHIFT).u32).Imm(Constants::STRING_LENGTH_OFFSET).u32
  } Else {
    convert_char_codes_to_u16_chars(codes_data, str_data, Cast(codes_count).u64)
    StoreI(new_str, OrI(ShlI(codes_count).Imm(Constants::STRING_LENGTH_SHIFT).u32).Imm(1).u32).Imm(Constants::STRING_LENGTH_OFFSET).u32
  }
  # String is supposed to be a constant object, so all its data should be visible by all threads
  Intrinsic(:DATA_MEMORY_BARRIER_FULL).void
  Return(new_str).ptr

Label(:SlowPathEntrypoint)
  entrypoint = get_entrypoint_offset("CREATE_STRING_FROM_CHAR_CODE_SLOW_PATH")
  Intrinsic(:SLOW_PATH_ENTRY, char_codes).AddImm(entrypoint).MethodAsImm("CreateStringFromCharCode2ArgBridge").Terminator.ptr
  Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
}

def GenerateCreateStringFromCharCodeSingleTlab(cache_flag)
  nocache = (cache_flag ? "" : "NoCache")
  param_tuple = (cache_flag ? {cache: 'ref', char_code: 'u64', string_klass: 'ref'}
                            : {char_code: 'u64', string_klass: 'ref'})
  available_regs = $panda_mask
  function("CreateStringFromCharCodeSingle#{nocache}Tlab".to_sym,
            params: param_tuple,
            regmap: $full_regmap,
            regalloc_set: available_regs,
            mode: [:FastPath]) {

    if Options.arch == :arm32
      Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
      ReturnVoid().void
      next
    end

    char_code_num := Bitcast(char_code).f64
    flag_char_pair := Intrinsic(:JS_CAST_DOUBLE_TO_CHAR, char_code_num).u32
    if !Options.jscvt_feature_enabled?
      # Validate if the char code is convertible: whenever an overflow or underflow takes place during the
      # conversion of a denormalized number we have to go to the slow path. The validation must take place before
      # any attempts to allocate the memory in TLAB.
      convertible := validate_flag_char_pair(flag_char_pair)
      If(convertible, 0).EQ.Unlikely {
        Goto(:SlowPathEntrypoint)
      }
    end

    char := get_char_from_flag_char_pair(flag_char_pair)
    # Try to read from the one-byte char cache
    if cache_flag
      IfImm(Compare(char, Constants::ASCII_CHAR_CACHE_SIZE).B.b).Imm(0).NE.b {
        Return(read_from_cache(cache, char)).ptr
      }
    end

    # Allocate a new string
    If(SubI(char).Imm(Constants::STRING_MUTF8_1B_MIN).u16, Cast(Constants::STRING_MUTF8_1B_MAX).u16).AE.Unlikely {
      compressible1 := Cast(0).b
      data_size1 := Cast(2).word
    } Else {
      compressible2 := Cast(1).b
      data_size2 := Cast(1).word
    }
    compressible := Phi(compressible1, compressible2).b
    data_size := Phi(data_size1, data_size2).word

    new_str := allocate_string_tlab(string_klass, data_size, :FastPath)
    str_data := Add(new_str, Cast(Constants::STRING_DATA_OFFSET).u64).ptr

    # Copy the char to the new string with the required preprocessing
    # String length field is set according to SetLength() from runtime/include/coretypes/string.h
    If(compressible, 1).EQ.Likely {
      Store(str_data, Cast(0).u64, char).u8
      StoreI(new_str, Cast(4).u32).Imm(Constants::STRING_LENGTH_OFFSET).u32
    } Else {
      Store(str_data, Cast(0).u64, char).u16
      StoreI(new_str, OrI(Cast(4).u32).Imm(1).u32).Imm(Constants::STRING_LENGTH_OFFSET).u32
    }

    # String is supposed to be a constant object, so all its data should be visible by all threads
    Intrinsic(:DATA_MEMORY_BARRIER_FULL).void
    Return(new_str).ptr

  Label(:SlowPathEntrypoint)
    entrypoint = get_entrypoint_offset("CREATE_STRING_FROM_CHAR_CODE_SINGLE_NO_CACHE_SLOW_PATH")
    Intrinsic(:SLOW_PATH_ENTRY, char_code).AddImm(entrypoint).MethodAsImm("CreateStringFromCharCodeSingleNoCache#{param_tuple.size}ArgBridge").Terminator.ptr
    Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
  }
end # def GenerateCreateStringFromCharCodeSingleTlab

GenerateCreateStringFromCharCodeSingleTlab(cache_flag=false)
GenerateCreateStringFromCharCodeSingleTlab(cache_flag=true)

# String contains 8-bit chars
# 0 < str_data_size < 8
function(:StringIndexOfCompressedSmall,
          params: {str_data: 'ptr', str_data_size: 'u32', ch: 'u8'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPathPlus]) {

  if Options.arch == :arm32 || Options.arch == :x86_64
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end
  i1 := 0
Label(:Loop)
  i := Phi(i1, i2).u32
  If(Load(str_data, i).u8, ch).EQ.Unlikely.b {
    Return(Cast(i).i32).i32
  }
  i2 := AddI(i).Imm(Constants::U8_SIZE).u32
  If(i2, str_data_size).LT.Likely.b {
    Goto(:Loop)
  }
  Return(-1).i32
}


# String contains 8-bit chars
# 8 <= str_data_size < 16
function(:StringIndexOfCompressedMedium,
          params: {str_data: 'ptr', str_data_size: 'u32', ch: 'u8'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPathPlus]) {

  if Options.arch == :arm32 || Options.arch == :x86_64
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  pattern := Cast(ch).u64
  pattern := Or(ShlI(pattern).Imm("ark::BITS_PER_BYTE").u64, pattern).u64
  pattern := Or(ShlI(pattern).Imm("ark::BITS_PER_UINT16").u64, pattern).u64
  pattern := Or(ShlI(pattern).Imm("ark::BITS_PER_UINT32").u64, pattern).u64
  value := LoadI(str_data).Imm(0).u64
  x := Xor(value, pattern).u64
  found := AndI(And(SubI(x).Imm(Constants::XOR_SUB_U8_MASK).u64, Not(x).u64).u64).Imm(Constants::XOR_AND_U8_MASK).u64
  If(found, 0).NE.Likely.b {
    rev := Intrinsic(:REVERSE_BYTES_U64, found).u64
    pos := Cast(ShrI(Intrinsic(:COUNT_LEADING_ZERO_BITS_U64, rev).u64).Imm(Constants::LOG2_BITS_PER_U8).u64).i32
    Return(pos).i32
  }
  i1 := Constants::MEM_BLOCK_8_BYTES
Label(:Loop)
  i := Phi(i1, i2).u32
  If(i, str_data_size).LT.Likely.b {
    If(Load(str_data, i).u8, ch).EQ.Unlikely.b {
      Return(Cast(i).i32).i32
    }
    i2 := AddI(i).Imm(Constants::U8_SIZE).u32
    Goto(:Loop)
  }
  Return(-1).i32
}


# 16 <= str_data_size < 32
function(:StringIndexOfCompressedLarge,
          params: {str_data: 'ptr', str_data_size: 'u32', ch: 'u8'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPathPlus]) {

  if Options.arch == :arm32 || Options.arch == :x86_64
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  # String contains 8-bit chars
  p := Intrinsic(:MEM_CHAR_U8_X16_USING_SIMD, ch, str_data).ptr
  If(p, 0).NE.Likely.b {
    Return(Cast(Sub(p, str_data).word).i32).i32
  }
  i1 := Constants::MEM_BLOCK_16_BYTES
Label(:Loop)
  i := Phi(i1, i2).u32
  If(i, str_data_size).LT.Likely.b {
    If(Load(str_data, i).u8, ch).EQ.Unlikely.b {
      Return(Cast(i).i32).i32
    }
    i2 := AddI(i).Imm(Constants::U8_SIZE).u32
    Goto(:Loop)
  }
  Return(-1).i32
}


# 32 <= data size
function(:StringIndexOfCompressed,
          params: {str_data: 'ptr', str_data_size: 'u32', ch: 'u8'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPathPlus]) {

  if Options.arch == :arm32 || Options.arch == :x86_64
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  # String contains 8-bit chars
  end_ptr := Add(str_data, Cast(str_data_size).word).ptr

  IfImm(Compare(str_data_size, Constants::MEM_BLOCK_32_BYTES).GE.b).Imm(0).NE.Likely.b {
    end_ptr_aligned := Bitcast(AndI(Bitcast(end_ptr).word).Imm(Constants::MEM_BLOCK_32_ALIGN_MASK).word).ptr
Label(:LoopSimd)
    curr_ptr := Phi(str_data, curr_ptr1).ptr;
    p := Intrinsic(:MEM_CHAR_U8_X32_USING_SIMD, ch, curr_ptr).ptr
    If(p, 0).NE.Likely.b {
      Return(Cast(Sub(p, str_data).word).i32).i32
    }
    curr_ptr1 := Add(curr_ptr, Constants::MEM_BLOCK_32_BYTES).ptr
    If(curr_ptr1, end_ptr_aligned).LT.Likely.b {
      Goto(:LoopSimd)
    }
    If(end_ptr_aligned, end_ptr).EQ.Unlikely.b {
      Return(-1).i32
    }
  }
  curr_ptr2 := Phi(str_data, curr_ptr1).ptr

  IfImm(Compare(Sub(end_ptr, curr_ptr2).word, Constants::MEM_BLOCK_16_BYTES).GE.b).Imm(0).NE.Likely.b {
    p := Intrinsic(:MEM_CHAR_U8_X16_USING_SIMD, ch, curr_ptr2).ptr
    If(p, 0).NE.Likely.b {
      Return(Cast(Sub(p, str_data).word).i32).i32
    }
    curr_ptr3 := AddI(curr_ptr2).Imm(Constants::MEM_BLOCK_16_BYTES).ptr
  }
  curr_ptr4 := Phi(curr_ptr2, curr_ptr3).ptr

Label(:Loop)
  curr_ptr5 := Phi(curr_ptr4, curr_ptr6).ptr
  If(curr_ptr5, end_ptr).LT.Likely.b {
    c := LoadI(curr_ptr5).Imm(0).u8
    If(c, ch).EQ.Unlikely.b {
      Return(Cast(Sub(curr_ptr5, str_data).word).i32).i32
    }
    curr_ptr6 := AddI(curr_ptr5).Imm(Constants::U8_SIZE).ptr
    Goto(:Loop)
  }
  Return(-1).i32
}

# 0 < str_data_size < 16
function(:StringIndexOfUncompressedSmall,
          params: {str_data: 'ptr', str_data_size: 'u32', ch: 'u16'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPathPlus]) {

  if Options.arch == :arm32 || Options.arch == :x86_64
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  # String contains 16-bit chars
  i1 := 0
Label(:Loop)
  i := Phi(i1, i2).u32
  If(Load(str_data, i).u16, ch).EQ.Unlikely.b {
    Return(Cast(ShrI(i).Imm(1).u32).i32).i32
  }
  i2 := AddI(i).Imm(Constants::U16_SIZE).u32
  If(i2, str_data_size).LT.Likely.b {
    Goto(:Loop)
  }
  Return(-1).i32
}


# 16 <= str_data_size < 32
function(:StringIndexOfUncompressedMedium,
          params: {str_data: 'ptr', str_data_size: 'u32', ch: 'u16'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPathPlus]) {

  if Options.arch == :arm32 || Options.arch == :x86_64
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  # String contains 16-bit chars
  p := Intrinsic(:MEM_CHAR_U16_X8_USING_SIMD, ch, str_data).ptr
  If(p, 0).NE.Likely.b {
    Return(Cast(ShrI(Sub(p, str_data).word).Imm(1).word).i32).i32
  }
  i1 := Constants::MEM_BLOCK_16_BYTES  # u16x8
Label(:Loop)
  i := Phi(i1, i2).u32
  If(i, str_data_size).LT.Likely.b {
    If(Load(str_data, i).u16, ch).EQ.Unlikely.b {
      Return(Cast(ShrI(i).Imm(1).u32).i32).i32
    }
    i2 := AddI(i).Imm(Constants::U16_SIZE).u32
    Goto(:Loop)
  }
  Return(-1).i32
}


# 32 <= data size
function(:StringIndexOfUncompressed,
          params: {str_data: 'ptr', str_data_size: 'u32', ch: 'u16'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPathPlus]) {

  if Options.arch == :arm32 || Options.arch == :x86_64
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  # String contains 16-bit chars
  end_ptr := Add(str_data, Cast(str_data_size).word).ptr

  IfImm(Compare(str_data_size, Constants::MEM_BLOCK_32_BYTES).GE.b).Imm(0).NE.Likely.b {
    end_ptr_aligned := Bitcast(AndI(Bitcast(end_ptr).word).Imm(Constants::MEM_BLOCK_32_ALIGN_MASK).word).ptr
Label(:LoopSimd)
    curr_ptr := Phi(str_data, curr_ptr1).ptr;
    p := Intrinsic(:MEM_CHAR_U16_X16_USING_SIMD, ch, curr_ptr).ptr
    If(p, 0).NE.Likely.b {
      Return(Cast(ShrI(Sub(p, str_data).word).Imm(1).word).i32).i32
    }
    curr_ptr1 := Add(curr_ptr, Constants::MEM_BLOCK_32_BYTES).ptr
    If(curr_ptr1, end_ptr_aligned).LT.Likely.b {
      Goto(:LoopSimd)
    }
    If(end_ptr_aligned, end_ptr).EQ.Unlikely.b {
       Return(-1).i32
    }
  }
  curr_ptr2 := Phi(str_data, curr_ptr1).ptr
  IfImm(Compare(Sub(end_ptr, curr_ptr2).word, Constants::MEM_BLOCK_16_BYTES).GE.b).Imm(0).NE.Likely.b {
    p := Intrinsic(:MEM_CHAR_U16_X8_USING_SIMD, ch, curr_ptr2).ptr
    If(p, 0).NE.Likely.b {
      Return(Cast(ShrI(Sub(p, str_data).word).Imm(1).word).i32).i32
    }
    curr_ptr3 := AddI(curr_ptr2).Imm(Constants::MEM_BLOCK_16_BYTES).ptr
  }
  curr_ptr4 := Phi(curr_ptr2, curr_ptr3).ptr

Label(:Loop)
  curr_ptr5 := Phi(curr_ptr4, curr_ptr6).ptr
  If(curr_ptr5, end_ptr).LT.Likely.b {
    If(LoadI(curr_ptr5).Imm(0).u16, ch).EQ.Unlikely.b {
      Return(Cast(ShrI(Sub(curr_ptr5, str_data).word).Imm(1).word).i32).i32
    }
    curr_ptr6 := AddI(curr_ptr5).Imm(Constants::U16_SIZE).ptr
    Goto(:Loop)
  }
  Return(-1).i32
}


def GenerateStringIndexOf(cgmode)
  suffix = (cgmode == :NativePlus ? 'NativePlus': '')
  upsuffix = (cgmode == :NativePlus ? '_NATIVE_PLUS': '')
  function("StringIndexOf#{suffix}".to_sym,
            params: {str_orig: 'ref', ch: 'u16', fake: 'i32'},
            regmap: $full_regmap,
            regalloc_set: $panda_mask,
            mode: [cgmode]) {

  if Options.arch == :arm32 || Options.arch == :x86_64
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  str_len_packed := LoadI(str_orig).Imm(Constants::STRING_LENGTH_OFFSET).u32

  # Check if str_orig is empty (return '-1' if so).
  # Currently, there are two special bits in a packed length:
  #   - lowest bit in length: 1:compressed/0:uncompressed.
  #   - second lowest bit in length: 1:string is in string table/0:not in string table.
  # Thus a string is considered to be empty if packed_length <= 3
  StaticAssertEQ(Constants::STRING_PACKED_LENGTH_ZERO, 3)
  IfImm(Compare(str_len_packed, Constants::STRING_PACKED_LENGTH_ZERO).LE.b).Imm(0).NE.Unlikely.b {
    Return(-1).i32
  }

  dispatch_on_string_type(str_orig, AsGlobalLabel(:LineString),
                                    AsGlobalLabel(:SlicedString),
                                    AsGlobalLabel(:TreeString))
LabelGlobal(:TreeString)
  tree_data := get_tree_data_ptr(str_orig, AsGlobalLabel(:SlowPathEntrypoint))
  Goto(:Flat)
LabelGlobal(:SlicedString)
  sliced_data := get_sliced_data_ptr(str_orig, str_len_packed)
  Goto(:Flat)
LabelGlobal(:LineString)
  line_data := Add(Cast(str_orig).SrcType(Constants::COMPILER_REFERENCE).ptr, Cast(Constants::STRING_DATA_OFFSET).word).ptr

Label(:Flat)
  str_data := Phi(tree_data, sliced_data, line_data).ptr
  IfImm(Compare(is_string_uncompressed_u32(str_len_packed), 1).EQ.b).Imm(0).NE.Unlikely.b {
    str_data_size_u16 := AndI(str_len_packed).Imm(0xFFFFFFFC).u32
    # 0 < data size < 16
    If(str_data_size_u16, 16).LT.Unlikely.b {
        LiveOut(str_data).DstReg(regmap[:arg0]).ptr
        LiveOut(str_data_size_u16).DstReg(regmap[:arg1]).u32
        LiveOut(ch).DstReg(regmap[:arg2]).u16
        name = "StringIndexOfUncompressedSmall#{suffix}"
        if cgmode == :NativePlus
          Return(Call(0, str_data, str_data_size_u16, ch).Method(name).i32).i32
        else
          entrypoint = get_entrypoint_offset("STRING_INDEX_OF_UNCOMPRESSED_SMALL#{upsuffix}")
          Intrinsic(:TAIL_CALL).AddImm(entrypoint).MethodAsImm(name).Terminator.i32
        end
    }
    # 16 <= data size < 32
    If(str_data_size_u16, 32).LT.Unlikely.b {
        LiveOut(str_data).DstReg(regmap[:arg0]).ptr
        LiveOut(str_data_size_u16).DstReg(regmap[:arg1]).u32
        LiveOut(ch).DstReg(regmap[:arg2]).u16
        name = "StringIndexOfUncompressedMedium#{suffix}"
        if cgmode == :NativePlus
          Return(Call(0, str_data, str_data_size_u16, ch).Method(name).i32).i32
        else
          entrypoint = get_entrypoint_offset("STRING_INDEX_OF_UNCOMPRESSED_MEDIUM#{upsuffix}")
          Intrinsic(:TAIL_CALL).AddImm(entrypoint).MethodAsImm(name).Terminator.i32
        end
    }
    # 32 <= data size
    LiveOut(str_data).DstReg(regmap[:arg0]).ptr
    LiveOut(str_data_size_u16).DstReg(regmap[:arg1]).u32
    LiveOut(ch).DstReg(regmap[:arg2]).u16
    name = "StringIndexOfUncompressed#{suffix}"
    if cgmode == :NativePlus
      Return(Call(0, str_data, str_data_size_u16, ch).Method(name).i32).i32
    else
      entrypoint = get_entrypoint_offset("STRING_INDEX_OF_UNCOMPRESSED#{upsuffix}")
      Intrinsic(:TAIL_CALL).AddImm(entrypoint).MethodAsImm(name).Terminator.i32
    end
  }

  IfImm(Compare(ch, Constants::MAX_U8_VALUE).A.b).Imm(0).NE.Unlikely.b {
    Return(-1).i32
  }

  str_data_size_u8 := ShrI(str_len_packed).Imm(Constants::STRING_LENGTH_SHIFT).u32
  # 0 < data size < 8
  If(str_data_size_u8, 8).LT.Unlikely.b {
    LiveOut(str_data).DstReg(regmap[:arg0]).ptr
    LiveOut(str_data_size_u8).DstReg(regmap[:arg1]).u32
    LiveOut(ch).DstReg(regmap[:arg2]).u8
    name = "StringIndexOfCompressedSmall#{suffix}"
    if cgmode == :NativePlus
      Return(Call(0, str_data, str_data_size_u8, ch).Method(name).i32).i32
    else
      entrypoint = get_entrypoint_offset("STRING_INDEX_OF_COMPRESSED_SMALL#{upsuffix}")
      Intrinsic(:TAIL_CALL).AddImm(entrypoint).MethodAsImm(name).Terminator.i32
    end
  }
  # 8 <= data size < 16
  If(str_data_size_u8, 16).LT.Unlikely.b {
    LiveOut(str_data).DstReg(regmap[:arg0]).ptr
    LiveOut(str_data_size_u8).DstReg(regmap[:arg1]).u32
    LiveOut(ch).DstReg(regmap[:arg2]).u8
    name = "StringIndexOfCompressed#{suffix}"
    if cgmode == :NativePlus
      Return(Call(0, str_data, str_data_size_u8, ch).Method(name).i32).i32
    else
      entrypoint = get_entrypoint_offset("STRING_INDEX_OF_COMPRESSED_MEDIUM#{upsuffix}")
      Intrinsic(:TAIL_CALL).AddImm(entrypoint).MethodAsImm(name).Terminator.i32
    end
  }
  # 16 <= data size < 32
  If(str_data_size_u8, 32).LT.Unlikely.b {
    LiveOut(str_data).DstReg(regmap[:arg0]).ptr
    LiveOut(str_data_size_u8).DstReg(regmap[:arg1]).u32
    LiveOut(ch).DstReg(regmap[:arg2]).u8
    name = "StringIndexOfCompressedLarge#{suffix}"
    if cgmode == :NativePlus
      Return(Call(0, str_data, str_data_size_u8, ch).Method(name).i32).i32
    else
      entrypoint = get_entrypoint_offset("STRING_INDEX_OF_COMPRESSED_LARGE#{upsuffix}")
      Intrinsic(:TAIL_CALL).AddImm(entrypoint).MethodAsImm(name).Terminator.i32
    end
  }
  # 32 <= data size
  LiveOut(str_data).DstReg(regmap[:arg0]).ptr
  LiveOut(str_data_size_u8).DstReg(regmap[:arg1]).u32
  LiveOut(ch).DstReg(regmap[:arg2]).u8
  name = "StringIndexOfCompressed#{suffix}"
  if cgmode == :NativePlus
    Return(Call(0, str_data, str_data_size_u8, ch).Method(name).i32).i32
  else
    entrypoint = get_entrypoint_offset("STRING_INDEX_OF_COMPRESSED#{upsuffix}")
    Intrinsic(:TAIL_CALL).AddImm(entrypoint).MethodAsImm(name).Terminator.i32
  end
LabelGlobal(:SlowPathEntrypoint)
  if cgmode == :NativePlus
      Return(Call(str_orig, ch).Method("StdCoreStringIndexOf").i32).i32
  else
    entrypoint = get_entrypoint_offset("STRING_INDEX_OF_SLOW_PATH")
    Intrinsic(:SLOW_PATH_ENTRY, str_orig, ch, fake).AddImm(entrypoint).MethodAsImm("StringIndexOfOddSavedBridge").Terminator.i32
    Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
  end
}
end

GenerateStringIndexOf(:FastPath)
GenerateStringIndexOf(:NativePlus)

# 'IndexOfAfter' calls the corresponding functions from the 'IndexOf' family
# for the purpose of code efficiency and to avoid code duplication.
# The problem is that we have to add 'start_index' to the result, but execution flow
# never returns to 'StringIndexOfAfter' because of TAIL_CALL. So the codegen and libllvm
# take care of it and emit instructions adding 'start_index' to the result returned
# by 'StringIndexOfAfter'.
def GenerateStringIndexOfAfter(cgmode)
  suffix = (cgmode == :NativePlus ? 'NativePlus': '')
  upsuffix = (cgmode == :NativePlus ? '_NATIVE_PLUS': '')
  function("StringIndexOfAfter#{suffix}".to_sym,
            params: {str_orig: 'ref', ch: 'u16', start_index: 'i32'},
            regmap: $full_regmap,
            regalloc_set: $panda_mask,
            mode: [cgmode]) {

  if Options.arch == :arm32 || Options.arch == :x86_64
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  # make any negative index zero only for Native mode as
  # the codegen takes care of it if the mode is FastPath
  if cgmode == :NativePlus
    start_index0 := start_index
    IfImm(Compare(start_index, 0).LT.b).Imm(0).NE.Unlikely.b {
      start_index1 := 0
    }
    start_index := Phi(start_index0, start_index1).i32
  end

  if cgmode == :NativePlus
    str := try_use_cached_flat_str_reject_sliced(str_orig, AsGlobalLabel(:SlowPathEntrypoint))
  else
    check_not_tree_string_type(str_orig) if defines.DEBUG
    # it still can be slice
    check_string_type(str_orig, AsGlobalLabel(:SlowPathEntrypoint))
    str := str_orig
  end

  str_len_packed := LoadI(str).Imm(Constants::STRING_LENGTH_OFFSET).u32
  # Return '-1' if 'str' is empty.
  IfImm(Compare(str_len_packed, 1).LE.b).Imm(0).NE.Unlikely.b {
    Return(-1).i32
  }

  str_len := ShrI(str_len_packed).Imm(Constants::STRING_LENGTH_SHIFT).i32

  # Return '-1' if 'start_index' is out of range
  If(start_index, str_len).GE.Unlikely.b {
    Return(-1).i32
  }

  str_data := Add(Cast(str).SrcType(Constants::COMPILER_REFERENCE).ptr, Cast(Constants::STRING_DATA_OFFSET).word).ptr

  IfImm(Compare(is_string_uncompressed_u32(str_len_packed), 1).EQ.b).Imm(0).NE.Unlikely.b {
    offs := Cast(ShlI(start_index).Imm(1).i32).u32
    data_size_u16 := AndI(str_len_packed).Imm(0xFFFFFFFE).u32
    data_size_u16 := Sub(data_size_u16, offs).u32
    data_ptr_u16 := Add(str_data, Cast(offs).word).ptr
    # 0 < data size < 16
    If(data_size_u16, 16).LT.Unlikely.b {
      LiveOut(data_ptr_u16).DstReg(regmap[:arg0]).ptr
      LiveOut(data_size_u16).DstReg(regmap[:arg1]).u32
      LiveOut(ch).DstReg(regmap[:arg2]).u16
      name = "StringIndexOfUncompressedSmall#{suffix}"
      if cgmode == :NativePlus
        rc0 := Call(0, data_ptr_u16, data_size_u16, ch).Method(name).i32
        If(rc0, -1).NE.b {
          rc1 := Add(rc0, start_index).i32
        }
        Return(Phi(rc0, rc1).i32).i32
      else
        entrypoint = get_entrypoint_offset("STRING_INDEX_OF_UNCOMPRESSED_SMALL#{upsuffix}")
        Intrinsic(:TAIL_CALL).AddImm(entrypoint).MethodAsImm(name).Terminator.i32
      end
    }
    # 16 <= data size < 32
    If(data_size_u16, 32).LT.Unlikely.b {
      LiveOut(data_ptr_u16).DstReg(regmap[:arg0]).ptr
      LiveOut(data_size_u16).DstReg(regmap[:arg1]).u32
      LiveOut(ch).DstReg(regmap[:arg2]).u16
      name = "StringIndexOfUncompressedMedium#{suffix}"
      if cgmode == :NativePlus
        rc0 := Call(0, data_ptr_u16, data_size_u16, ch).Method(name).i32
        If(rc0, -1).NE.b {
          rc1 := Add(rc0, start_index).i32
        }
        Return(Phi(rc0, rc1).i32).i32
      else
        entrypoint = get_entrypoint_offset("STRING_INDEX_OF_UNCOMPRESSED_MEDIUM#{upsuffix}")
        Intrinsic(:TAIL_CALL).AddImm(entrypoint).MethodAsImm(name).Terminator.i32
      end
    }
    # 32 <= data size
    LiveOut(data_ptr_u16).DstReg(regmap[:arg0]).ptr
    LiveOut(data_size_u16).DstReg(regmap[:arg1]).u32
    LiveOut(ch).DstReg(regmap[:arg2]).u16
    name = "StringIndexOfUncompressed#{suffix}"
    if cgmode == :NativePlus
      rc0 := Call(0, data_ptr_u16, data_size_u16, ch).Method(name).i32
      If(rc0, -1).NE.b {
        rc1 := Add(rc0, start_index).i32
      }
      Return(Phi(rc0, rc1).i32).i32
    else
      entrypoint = get_entrypoint_offset("STRING_INDEX_OF_UNCOMPRESSED#{upsuffix}")
      Intrinsic(:TAIL_CALL).AddImm(entrypoint).MethodAsImm(name).Terminator.i32
    end
  }

  IfImm(Compare(ch, Constants::MAX_U8_VALUE).A.b).Imm(0).NE.Unlikely.b {
    # Return '-1' as 'str' is compressed and 'ch' does not fit in 8 bits.
    Return(-1).i32
  }

  data_size_u8 := Sub(str_len, Cast(start_index).u32).u32
  data_ptr_u8 := Add(str_data, Cast(start_index).word).ptr
  # 0 < data size < 8
  If(data_size_u8, 8).LT.Unlikely.b {
    LiveOut(data_ptr_u8).DstReg(regmap[:arg0]).ptr
    LiveOut(data_size_u8).DstReg(regmap[:arg1]).u32
    LiveOut(ch).DstReg(regmap[:arg2]).u8
    name = "StringIndexOfCompressedSmall#{suffix}"
    if cgmode == :NativePlus
      rc0 := Call(0, data_ptr_u8, data_size_u8, ch).Method(name).i32
      If(rc0, -1).NE.b {
        rc1 := Add(rc0, start_index).i32
      }
      Return(Phi(rc0, rc1).i32).i32
    else
      entrypoint = get_entrypoint_offset("STRING_INDEX_OF_COMPRESSED_SMALL#{upsuffix}")
      Intrinsic(:TAIL_CALL).AddImm(entrypoint).MethodAsImm(name).Terminator.i32
    end
  }
  # 8 <= data size < 16
  If(data_size_u8, 16).LT.Unlikely.b {
    LiveOut(data_ptr_u8).DstReg(regmap[:arg0]).ptr
    LiveOut(data_size_u8).DstReg(regmap[:arg1]).u32
    LiveOut(ch).DstReg(regmap[:arg2]).u8
    name = "StringIndexOfCompressedMedium#{suffix}"
    if cgmode == :NativePlus
      rc0 := Call(0, data_ptr_u8, data_size_u8, ch).Method(name).i32
      If(rc0, -1).NE.b {
          rc1 := Add(rc0, start_index).i32
      }
      Return(Phi(rc0, rc1).i32).i32
    else
      entrypoint = get_entrypoint_offset("STRING_INDEX_OF_COMPRESSED_MEDIUM#{upsuffix}")
      Intrinsic(:TAIL_CALL).AddImm(entrypoint).MethodAsImm(name).Terminator.i32
    end
  }
  # 16 <= data size < 32
  If(data_size_u8, 32).LT.Unlikely.b {
    LiveOut(data_ptr_u8).DstReg(regmap[:arg0]).ptr
    LiveOut(data_size_u8).DstReg(regmap[:arg1]).u32
    LiveOut(ch).DstReg(regmap[:arg2]).u8
    name = "StringIndexOfCompressedLarge#{suffix}"
    if cgmode == :NativePlus
      rc0 := Call(0, data_ptr_u8, data_size_u8, ch).Method(name).i32
      If(rc0, -1).NE.b {
        rc1 := Add(rc0, start_index).i32
      }
      Return(Phi(rc0, rc1).i32).i32
    else
      entrypoint = get_entrypoint_offset("STRING_INDEX_OF_COMPRESSED_LARGE#{upsuffix}")
      Intrinsic(:TAIL_CALL).AddImm(entrypoint).MethodAsImm(name).Terminator.i32
    end
  }
  # 32 <= data size
  LiveOut(data_ptr_u8).DstReg(regmap[:arg0]).ptr
  LiveOut(data_size_u8).DstReg(regmap[:arg1]).u32
  LiveOut(ch).DstReg(regmap[:arg2]).u8
  name = "StringIndexOfCompressed#{suffix}"
  if cgmode == :NativePlus
    rc0 := Call(0, data_ptr_u8, data_size_u8, ch).Method(name).i32
    If(rc0, -1).NE.b {
      rc1 := Add(rc0, start_index).i32
    }
    Return(Phi(rc0, rc1).i32).i32
  else
    entrypoint = get_entrypoint_offset("STRING_INDEX_OF_COMPRESSED#{upsuffix}")
    Intrinsic(:TAIL_CALL).AddImm(entrypoint).MethodAsImm(name).Terminator.i32
  end
LabelGlobal(:SlowPathEntrypoint)
  if cgmode == :NativePlus
      Return(Call(str_orig, ch, start_index).Method("StdCoreStringIndexOfAfter").i32).i32
  else
    entrypoint = get_entrypoint_offset("STRING_INDEX_OF_AFTER_SLOW_PATH")
    Intrinsic(:SLOW_PATH_ENTRY, str_orig, ch, start_index).AddImm(entrypoint).MethodAsImm("StringIndexOfAfterOddSavedBridge").Terminator.i32
    Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
  end
}
end

GenerateStringIndexOfAfter(:FastPath)
GenerateStringIndexOfAfter(:NativePlus)


function(:StringLastIndexOfCompressedPlain,
          params: {str_data: 'ptr', start_index: 'u32', ch: 'u8'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPathPlus]) {

  if Options.arch == :arm32 || Options.arch == :x86_64
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end
  # String contains 8-bit chars
  # It's assumed that 0 <= start_index < string.length
Label(:Loop)
  i := Phi(start_index, i2).u32
  If(Load(str_data, i).u8, ch).EQ.Unlikely.b {
    Return(Cast(i).i32).i32
  }
  If(i, 0).EQ.Unlikely.b {
    Return(-1).i32
  }
  i2 := SubI(i).Imm(Constants::U8_SIZE).u32
  Goto(:Loop)
}


function(:StringLastIndexOfCompressedSimd,
          params: {str_data: 'ptr', start_index: 'u32', ch: 'u8'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPathPlus]) {

  if Options.arch == :arm32 || Options.arch == :x86_64
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end
  # String contains 8-bit chars
  # Check alignment (it's assumed that 0 <= start_index < string.length)
  str_end := Add(str_data, AddI(start_index).Imm(1).u32).ptr
  If(AndI(Bitcast(str_end).word).Imm(Constants::ADDR_16_BYTE_ALIGNED_MASK).word, 0).EQ.Unlikely.b {
    Goto(:Simd)
  }
  # Check by u8 char until address is 16-byte aligned (i.e. SIMD ready)
  ch_ptr1 := Add(str_data, start_index).ptr
Label(:LoopByChar1)
  ch_ptr := Phi(ch_ptr1, ch_ptr2).ptr
  If(LoadI(ch_ptr).Imm(0).u8, ch).EQ.Unlikely.b {
    Return(Cast(Sub(ch_ptr, str_data).word).i32).i32
  }
  If(AndI(Bitcast(ch_ptr).word).Imm(Constants::ADDR_16_BYTE_ALIGNED_MASK).u32, 0).EQ.Unlikely.b {
    Goto(:Simd)
  }
  ch_ptr2 := SubI(ch_ptr).Imm(Constants::U8_SIZE).ptr
  Goto(:LoopByChar1)
  # Check by 16-byte blocks using SIMD intrinsic
Label(:Simd)
  blk_end := Phi(str_end, ch_ptr).ptr
  blk_start1 := SubI(blk_end).Imm(Constants::MEM_BLOCK_16_BYTES).ptr
Label(:LoopSimd)
  blk_start := Phi(blk_start1, blk_start2).ptr
  p := Intrinsic(:MEM_LAST_CHAR_U8_X16_USING_SIMD, ch, blk_start).ptr
  If(p, 0).NE.Likely.b {
    Return(Cast(Sub(p, str_data).word).i32).i32
  }
  If(Sub(blk_start, str_data).u32, Constants::MEM_BLOCK_16_BYTES).GE.Likely.b {
    blk_start2 := SubI(blk_start).Imm(Constants::MEM_BLOCK_16_BYTES).ptr
    Goto(:LoopSimd)
  }
  If(blk_start, str_data).EQ.Unlikely.b {
    Return(-1).i32
  }
  ch_ptr3 := SubI(blk_start).Imm(Constants::U8_SIZE).ptr
Label(:LoopByChar2)
  ch_ptr4 := Phi(ch_ptr3, ch_ptr5).ptr
  If(LoadI(ch_ptr4).Imm(0).u8, ch).EQ.Unlikely.b {
    Return(Cast(Sub(ch_ptr4, str_data).word).i32).i32
  }
  If(ch_ptr4, str_data).GT.Likely.b {
    ch_ptr5 := SubI(ch_ptr4).Imm(Constants::U8_SIZE).ptr
    Goto(:LoopByChar2)
  }
  Return(-1).i32
}


function(:StringLastIndexOfUncompressedPlain,
          params: {str_data: 'ptr', start_index: 'u32', ch: 'u16'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPathPlus]) {

  if Options.arch == :arm32 || Options.arch == :x86_64
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  # String contains 16-bit chars
  # It's assumed that 0 <= start_index < string.length
  i1 := ShlI(start_index).Imm(1).u32
Label(:Loop)
  i := Phi(i1, i2).u32
  If(Load(str_data, i).u16, ch).EQ.Unlikely.b {
    Return(Cast(ShrI(i).Imm(1).u32).i32).i32
  }
  If(i, 0).EQ.Unlikely.b {
    Return(-1).i32
  }
  i2 := SubI(i).Imm(Constants::U16_SIZE).u32
  Goto(:Loop)
}


function(:StringLastIndexOfUncompressedSimd,
          params: {str_data: 'ptr', start_index: 'u32', ch: 'u16'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPathPlus]) {

  if Options.arch == :arm32 || Options.arch == :x86_64
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  # String contains 16-bit chars
  # Check alignment (it's assumed that 0 <= start_index < string.length)
  str_end := Add(str_data, ShlI(AddI(start_index).Imm(1).u32).Imm(1).u32).ptr
  If(AndI(Bitcast(str_end).word).Imm(Constants::ADDR_16_BYTE_ALIGNED_MASK).word, 0).EQ.Unlikely.b {
    Goto(:Simd)
  }
  # Check each u16 char until address is 16-byte aligned (i.e. SIMD ready)
  ch_ptr1 := Add(str_data, ShlI(start_index).Imm(1).u32).ptr
Label(:LoopByChar1)
  ch_ptr := Phi(ch_ptr1, ch_ptr2).ptr
  If(LoadI(ch_ptr).Imm(0).u16, ch).EQ.Unlikely.b {
    Return(Cast(ShrI(Sub(ch_ptr, str_data).word).Imm(1).u32).i32).i32
  }
  If(AndI(Bitcast(ch_ptr).word).Imm(Constants::ADDR_16_BYTE_ALIGNED_MASK).u32, 0).EQ.Unlikely.b {
    Goto(:Simd)
  }
  ch_ptr2 := SubI(ch_ptr).Imm(Constants::U16_SIZE).ptr
  Goto(:LoopByChar1)
  # Check by 16-byte blocks using SIMD intrinsic
Label(:Simd)
  blk_end := Phi(str_end, ch_ptr).ptr
  blk_start1 := SubI(blk_end).Imm(Constants::MEM_BLOCK_16_BYTES).ptr
Label(:LoopSimd)
  blk_start := Phi(blk_start1, blk_start2).ptr
  p := Intrinsic(:MEM_LAST_CHAR_U16_X8_USING_SIMD, ch, blk_start).ptr
  If(p, 0).NE.Likely.b {
    Return(Cast(ShrI(Sub(p, str_data).word).Imm(1).word).i32).i32
  }
  If(Sub(blk_start, str_data).u32, Constants::MEM_BLOCK_16_BYTES).GE.Likely.b {
    blk_start2 := SubI(blk_start).Imm(Constants::MEM_BLOCK_16_BYTES).ptr
    Goto(:LoopSimd)
  }
  If(blk_start, str_data).EQ.Unlikely.b {
    Return(-1).i32
  }
  ch_ptr3 := SubI(blk_start).Imm(Constants::U16_SIZE).ptr
Label(:LoopByChar2)
  ch_ptr4 := Phi(ch_ptr3, ch_ptr5).ptr
  If(LoadI(ch_ptr4).Imm(0).u16, ch).EQ.Unlikely.b {
    Return(Cast(ShrI(Sub(ch_ptr4, str_data).word).Imm(1).word).i32).i32
  }
  If(ch_ptr4, str_data).GT.Likely.b {
    ch_ptr5 := SubI(ch_ptr4).Imm(Constants::U16_SIZE).ptr
    Goto(:LoopByChar2)
  }
  Return(-1).i32
}


def GenerateStringLastIndexOf(cgmode)
  suffix = (cgmode == :NativePlus ? 'NativePlus': '')
  upsuffix = (cgmode == :NativePlus ? '_NATIVE_PLUS': '')
  function("StringLastIndexOf#{suffix}".to_sym,
            params: {str_orig: 'ref', ch: 'u16', start_index: 'i32'},
            regmap: $full_regmap,
            regalloc_set: $panda_mask,
            mode: [cgmode]) {

  if Options.arch == :arm32 || Options.arch == :x86_64
    Intrinsic(:UNREACHABLE).Terminator.void
    ReturnVoid().void
    next
  end

  if cgmode == :NativePlus
    # Negative startIndex implies no match, i.e. return -1
    IfImm(Compare(start_index, 0).LT.b).Imm(0).NE.Unlikely.b {
      Return(-1).i32
    }
  end  # NativePlus

  str_len_packed := LoadI(str_orig).Imm(Constants::STRING_LENGTH_OFFSET).u32

  # String's emptiness and validity of start index are checked in Codegen::CreateStringLastIndexOf.
  # So we have to explicitly check them here iff 'NativePlus' mode is in effect.
  if cgmode == :NativePlus
    # Check if str_orig is empty (return '-1' if so).
    # Currently, there are two special bits in a packed length:
    #   - lowest bit in length: 1:compressed/0:uncompressed.
    #   - second lowest bit in length: 1:string is in string table/0:not in string table.
    # Thus a string is considered to be empty if packed_length <= 3
    StaticAssertEQ(Constants::STRING_PACKED_LENGTH_ZERO, 3)
    # Empty string implies no match, i.e. return -1
    IfImm(Compare(str_len_packed, Constants::STRING_PACKED_LENGTH_ZERO).LE.b).Imm(0).NE.Unlikely.b {
      Return(-1).i32
    }
    # Make startIndex = str.length - 1 if startIndex >= str.length
    str_len := ShrI(str_len_packed).Imm(Constants::STRING_LENGTH_SHIFT).u32
    index0 := Cast(start_index).u32
    If(index0, str_len).AE.Unlikely.b {
      index1 := SubI(str_len).Imm(1).u32
    }
    # str_len is 30-bit in size and index <= str_len - 1, so u32->i32 is safe here.
    start_index := Cast(Phi(index0, index1).u32).i32
  end  # NativePlus

  dispatch_on_string_type(str_orig, AsGlobalLabel(:LineString),
                                    AsGlobalLabel(:SlicedString),
                                    AsGlobalLabel(:TreeString))
LabelGlobal(:TreeString)
  tree_data := get_tree_data_ptr(str_orig, AsGlobalLabel(:SlowPathEntrypoint))
  Goto(:Flat)
LabelGlobal(:SlicedString)
  sliced_data := get_sliced_data_ptr(str_orig, str_len_packed)
  Goto(:Flat)
LabelGlobal(:LineString)
  line_data := Add(Cast(str_orig).SrcType(Constants::COMPILER_REFERENCE).ptr, Cast(Constants::STRING_DATA_OFFSET).word).ptr

Label(:Flat)
  str_data := Phi(tree_data, sliced_data, line_data).ptr

  uncompressed := Compare(AndI(str_len_packed).Imm(1).i32, 1).EQ.b
  IfImm(uncompressed).Imm(0).NE.Unlikely.b {
    # char is u16 and start_index is zero-based
    If(start_index, 7).LT.Unlikely.b {
      LiveOut(str_data).DstReg(regmap[:arg0]).ptr
      LiveOut(start_index).DstReg(regmap[:arg1]).u32
      LiveOut(ch).DstReg(regmap[:arg2]).u16
      name = "StringLastIndexOfUncompressedPlain#{suffix}"
      if cgmode == :NativePlus
        Return(Call(0, str_data, start_index, ch).Method(name).i32).i32
      else
        entrypoint = get_entrypoint_offset("STRING_LAST_INDEX_OF_UNCOMPRESSED_PLAIN#{upsuffix}")
        Intrinsic(:TAIL_CALL).AddImm(entrypoint).MethodAsImm(name).Terminator.i32
      end
    }
    LiveOut(str_data).DstReg(regmap[:arg0]).ptr
    LiveOut(start_index).DstReg(regmap[:arg1]).u32
    LiveOut(ch).DstReg(regmap[:arg2]).u16
    name = "StringLastIndexOfUncompressedSimd#{suffix}"
    if cgmode == :NativePlus
      Return(Call(0, str_data, start_index, ch).Method(name).i32).i32
    else
      entrypoint = get_entrypoint_offset("STRING_LAST_INDEX_OF_UNCOMPRESSED_SIMD#{upsuffix}")
      Intrinsic(:TAIL_CALL).AddImm(entrypoint).MethodAsImm(name).Terminator.i32
    end
  }  # u16 string

  IfImm(Compare(ch, Constants::MAX_U8_VALUE).A.b).Imm(0).NE.Unlikely.b {
    Return(-1).i32
  }

  # char is u8 and start_index is zero-based
  If(start_index, 15).LT.Unlikely.b {
    LiveOut(str_data).DstReg(regmap[:arg0]).ptr
    LiveOut(start_index).DstReg(regmap[:arg1]).u32
    LiveOut(ch).DstReg(regmap[:arg2]).u8
    name = "StringLastIndexOfCompressedPlain#{suffix}"
    if cgmode == :NativePlus
      Return(Call(0, str_data, start_index, ch).Method(name).i32).i32
    else
      entrypoint = get_entrypoint_offset("STRING_LAST_INDEX_OF_COMPRESSED_PLAIN#{upsuffix}")
      Intrinsic(:TAIL_CALL).AddImm(entrypoint).MethodAsImm(name).Terminator.i32
    end
  }
  LiveOut(str_data).DstReg(regmap[:arg0]).ptr
  LiveOut(start_index).DstReg(regmap[:arg1]).u32
  LiveOut(ch).DstReg(regmap[:arg2]).u8
  name = "StringLastIndexOfCompressedSimd#{suffix}"
  if cgmode == :NativePlus
    Return(Call(0, str_data, start_index, ch).Method(name).i32).i32
  else
    entrypoint = get_entrypoint_offset("STRING_LAST_INDEX_OF_COMPRESSED_SIMD#{upsuffix}")
    Intrinsic(:TAIL_CALL).AddImm(entrypoint).MethodAsImm(name).Terminator.i32
  end
LabelGlobal(:SlowPathEntrypoint)
  if cgmode == :NativePlus
      Return(Call(str_orig, ch, start_index).Method("StdCoreStringLastIndexOf").i32).i32
  else
    entrypoint = get_entrypoint_offset("STRING_LAST_INDEX_OF_SLOW_PATH")
    Intrinsic(:SLOW_PATH_ENTRY, str_orig, ch, start_index).AddImm(entrypoint).MethodAsImm("StringLastIndexOfOddSavedBridge").Terminator.i32
    Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
  end
}
end  # GenerateStringLastIndexOf

GenerateStringLastIndexOf(:FastPath)
GenerateStringLastIndexOf(:NativePlus)


def GenerateStringRepeatTlab(cgmode)
  function("StringRepeatTlab#{(cgmode == :NativePlus ? 'NativePlus' : '')}".to_sym,
          params: {str_orig: 'ref', cnt: 'i32'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [cgmode]) {

  if Options.arch == :arm32
    Intrinsic(:UNREACHABLE).Terminator.void
    next
  end

  count := Cast(cnt).u32
  IfImm(Compare(count, 0).LT.b).Imm(0).NE {
    Goto(:SlowPathEntrypoint)
  }

  if cgmode == :NativePlus
    str := try_use_cached_flat_str_reject_sliced(str_orig, AsGlobalLabel(:SlowPathEntrypoint))
  else
    check_not_tree_string_type(str_orig) if defines.DEBUG
    # it still can be slice
    check_string_type(str_orig, AsGlobalLabel(:SlowPathEntrypoint))
    str := str_orig
  end

  IfImm(Compare(count, 0).EQ.b).Imm(0).NE {
    new_str := allocate_string_tlab(load_core_string_class(), Cast(0).u64, cgmode);
    # String is supposed to be a constant object, so all its data should be visible by all threads
    Intrinsic(:DATA_MEMORY_BARRIER_FULL).void
    Return(new_str).ptr
  }

  IfImm(Compare(count, 1).EQ.b).Imm(0).NE {
    Return(Cast(str).ptr).ptr
  }

  length := LoadI(str).Imm(Constants::STRING_LENGTH_OFFSET).u32;
  old_buf := AddI(str).Imm(Constants::STRING_DATA_OFFSET).ptr
  uncompressed := is_string_uncompressed_u32(length)
  codes_count := ShrI(length).Imm(Constants::STRING_LENGTH_SHIFT).u32
  length := Shl(ShrI(length).Imm(Constants::STRING_LENGTH_SHIFT).u32, uncompressed).u32
  size := Mul(length, count).u32
  codes_count := Mul(codes_count, count).u32
  new_str := allocate_string_tlab(load_core_string_class(), Cast(size).u64, cgmode);
  new_buf := AddI(new_str).Imm(Constants::STRING_DATA_OFFSET).ptr

  If(new_str, 0).EQ {
    Goto(:SlowPathEntrypoint)
  }

  i0 := Cast(0).u32
Label(:outer)
  i := Phi(i0, i1).u32
  If(i, count).GE {
    Goto(:End)
  }
  offset := Mul(i, length).u32

  j0 := Cast(0).u32
  Label(:inner)
    j := Phi(j0, j1).u32
    If(j, length).GE {
      Goto(:endInner)
    }
    Store(new_buf, Add(offset, j).u32, Load(old_buf, j).u8).u8
    j1 := AddI(j).Imm(1).u32
    Goto(:inner)
  Label(:endInner)
  i1 := AddI(i).Imm(1).u32
  Goto(:outer)

Label(:End)
  If(uncompressed, 0).EQ.Likely {
    StoreI(new_str, ShlI(codes_count).Imm(Constants::STRING_LENGTH_SHIFT).u32).Imm(Constants::STRING_LENGTH_OFFSET).u32
  } Else {
    StoreI(new_str, OrI(ShlI(codes_count).Imm(Constants::STRING_LENGTH_SHIFT).u32).Imm(1).u32).Imm(Constants::STRING_LENGTH_OFFSET).u32
  }
  # String is supposed to be a constant object, so all its data should be visible by all threads
  Intrinsic(:DATA_MEMORY_BARRIER_FULL).void
  Return(new_str).ptr

LabelGlobal(:SlowPathEntrypoint)
  if cgmode == :NativePlus
    Return(Call(str_orig, count).Method('StdCoreStringRepeat').ptr).ptr
  else
    entrypoint = get_entrypoint_offset("STRING_REPEAT_SLOW_PATH")
    Intrinsic(:SLOW_PATH_ENTRY, str_orig, count).AddImm(entrypoint).MethodAsImm("StringRepeatUsualBridge").Terminator.ptr
    Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
  end
}
end
GenerateStringRepeatTlab(:FastPath)
GenerateStringRepeatTlab(:NativePlus)

def GenerateStringConcat2Tlab(cgmode)
  function("StringConcat2Tlab#{(cgmode == :NativePlus ? 'NativePlus' : '')}".to_sym,
            params: {str1_orig: 'ref', str2_orig: 'ref'},
            regmap: $full_regmap,
            regalloc_set: $panda_mask,
            mode: [cgmode]) {

    if Options.arch == :arm32
      Intrinsic(:UNREACHABLE).void.Terminator
      next
    end

    str1 := try_use_cached_flat_str_reject_sliced(str1_orig, AsGlobalLabel(:SlowPathEntrypoint))
    str2 := try_use_cached_flat_str_reject_sliced(str2_orig, AsGlobalLabel(:SlowPathEntrypoint))

    length1 := LoadI(str1).Imm(Constants::STRING_LENGTH_OFFSET).u32
    length2 := LoadI(str2).Imm(Constants::STRING_LENGTH_OFFSET).u32

    # any of the strings is uncompressed (resulted string is uncompressed)
    has_uncompressed := is_string_uncompressed_u32(Or(length1, length2).u32)

    count1 := ShrI(length1).Imm(Constants::STRING_LENGTH_SHIFT).u32
    count2 := ShrI(length2).Imm(Constants::STRING_LENGTH_SHIFT).u32

    size := Add(count1, count2).u32
    data_size := Shl(size, has_uncompressed).u32
    length := Or(ShlI(size).Imm(Constants::STRING_LENGTH_SHIFT).u32, has_uncompressed).u32
    new_str := allocate_string_tlab(load_core_string_class(), data_size, cgmode)

    StoreI(new_str, length).Imm(Constants::STRING_LENGTH_OFFSET).u32
    StoreI(new_str, Cast(0).u32).Imm(Constants::STRING_HASHCODE_OFFSET).u32

    src_str_data1 := AddI(str1).Imm(Constants::STRING_DATA_OFFSET).ptr
    dst_str_data1 := AddI(new_str).Imm(Constants::STRING_DATA_OFFSET).ptr

    # has no uncompressed then everyting is compressed, data is stored as bytes
    If(has_uncompressed, 0).EQ.b {
      copy_u8_chars(src_str_data1, dst_str_data1, count1)

      offset := count1

      src_str_data2 := AddI(str2).Imm(Constants::STRING_DATA_OFFSET).ptr
      dst_str_data2 := Add(AddI(new_str).Imm(Constants::STRING_DATA_OFFSET).ptr, offset).ptr
      copy_u8_chars(src_str_data2, dst_str_data2, count2)
      Goto(:EndCopy)
    }

    If(is_string_uncompressed_u32(length1), 0).EQ.b {
      expand_u8_to_u16_chars(src_str_data1, dst_str_data1, count1)
    } Else {
      copy_u16_chars(src_str_data1, dst_str_data1, count1)
    }

    offset := ShlI(count1).Imm(1).u32
    src_str_data2 := AddI(str2).Imm(Constants::STRING_DATA_OFFSET).ptr
    dst_str_data2 := Add(AddI(new_str).Imm(Constants::STRING_DATA_OFFSET).ptr, offset).ptr

    If(is_string_uncompressed_u32(length2), 0).EQ.b {
      expand_u8_to_u16_chars(src_str_data2, dst_str_data2, count2)
    } Else {
      copy_u16_chars(src_str_data2, dst_str_data2, count2)
    }

    Label(:EndCopy)

    # String is supposed to be a constant object, so all its data should be visible by all threads
    Intrinsic(:DATA_MEMORY_BARRIER_FULL).void
    Return(new_str).ptr

LabelGlobal(:SlowPathEntrypoint)
    if cgmode == :NativePlus
      Return(Call(str1_orig, str2_orig).Method('CoreStringConcat2').ptr).ptr
    else
      ep_offset = get_entrypoint_offset("STRING_CONCAT2_SLOW_PATH")
      Intrinsic(:SLOW_PATH_ENTRY, str1_orig, str2_orig).AddImm(ep_offset).MethodAsImm("StringConcat2UsualBridge").Terminator.ptr
      Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
    end
}
end

GenerateStringConcat2Tlab(:FastPath)
GenerateStringConcat2Tlab(:NativePlus)

def GenerateStringConcat3Tlab(cgmode)
  function("StringConcat3Tlab#{(cgmode == :NativePlus ? 'NativePlus' : '')}".to_sym,
           params: {str1_orig: 'ref', str2_orig: 'ref', str3_orig: 'ref'},
           regmap: $full_regmap,
           regalloc_set: $panda_mask,
           mode: [cgmode]) {

    if Options.arch == :arm32
      Intrinsic(:UNREACHABLE).void.Terminator
      next
    end

    str1 := try_use_cached_flat_str_reject_sliced(str1_orig, AsGlobalLabel(:SlowPathEntrypoint))
    str2 := try_use_cached_flat_str_reject_sliced(str2_orig, AsGlobalLabel(:SlowPathEntrypoint))
    str3 := try_use_cached_flat_str_reject_sliced(str3_orig, AsGlobalLabel(:SlowPathEntrypoint))

    length1 := LoadI(str1).Imm(Constants::STRING_LENGTH_OFFSET).u32
    length2 := LoadI(str2).Imm(Constants::STRING_LENGTH_OFFSET).u32
    length3 := LoadI(str3).Imm(Constants::STRING_LENGTH_OFFSET).u32

    has_uncompressed := is_string_uncompressed_u32(Or(length3, Or(length1, length2).u32).u32)

    count1 := ShrI(length1).Imm(Constants::STRING_LENGTH_SHIFT).u32
    count2 := ShrI(length2).Imm(Constants::STRING_LENGTH_SHIFT).u32
    count3 := ShrI(length3).Imm(Constants::STRING_LENGTH_SHIFT).u32

    size := Add(count1, Add(count2, count3).u32).u32
    data_size := Shl(size, has_uncompressed).u32
    length := Or(ShlI(size).Imm(Constants::STRING_LENGTH_SHIFT).u32, has_uncompressed).u32
    new_str := allocate_string_tlab(load_core_string_class(), data_size, cgmode)

    StoreI(new_str, length).Imm(Constants::STRING_LENGTH_OFFSET).u32
    StoreI(new_str, Cast(0).u32).Imm(Constants::STRING_HASHCODE_OFFSET).u32

    src_str_data1 := AddI(str1).Imm(Constants::STRING_DATA_OFFSET).ptr
    dst_str_data1 := AddI(new_str).Imm(Constants::STRING_DATA_OFFSET).ptr

    offset1 := ShlI(count1).Imm(1).u32
    offset2 := Add(offset1, ShlI(count2).Imm(1).u32).u32

    # everything is compressed
    If(has_uncompressed, 0).EQ.b {
      copy_u8_chars(src_str_data1, dst_str_data1, count1)

      offset1_ := ShrI(offset1).Imm(1).u32

      src_str_data2 := AddI(str2).Imm(Constants::STRING_DATA_OFFSET).ptr
      dst_str_data2 := Add(AddI(new_str).Imm(Constants::STRING_DATA_OFFSET).ptr, offset1_).ptr
      copy_u8_chars(src_str_data2, dst_str_data2, count2)

      offset2_ := ShrI(offset2).Imm(1).u32

      src_str_data3 := AddI(str3).Imm(Constants::STRING_DATA_OFFSET).ptr
      dst_str_data3 := Add(AddI(new_str).Imm(Constants::STRING_DATA_OFFSET).ptr, offset2_).ptr
      copy_u8_chars(src_str_data3, dst_str_data3, count3)
      Goto(:EndCopy)
    }

    If(is_string_uncompressed_u32(length1), 0).EQ.b {
      expand_u8_to_u16_chars(src_str_data1, dst_str_data1, count1)
    } Else {
      copy_u16_chars(src_str_data1, dst_str_data1, count1)
    }

    src_str_data2 := AddI(str2).Imm(Constants::STRING_DATA_OFFSET).ptr
    dst_str_data2 := Add(AddI(new_str).Imm(Constants::STRING_DATA_OFFSET).ptr, offset1).ptr

    If(is_string_uncompressed_u32(length2), 0).EQ.b {
      expand_u8_to_u16_chars(src_str_data2, dst_str_data2, count2)
    } Else {
      copy_u16_chars(src_str_data2, dst_str_data2, count2)
    }

    src_str_data3 := AddI(str3).Imm(Constants::STRING_DATA_OFFSET).ptr
    dst_str_data3 := Add(AddI(new_str).Imm(Constants::STRING_DATA_OFFSET).ptr, offset2).ptr

    If(is_string_uncompressed_u32(length3), 0).EQ.b {
      expand_u8_to_u16_chars(src_str_data3, dst_str_data3, count3)
    } Else {
      copy_u16_chars(src_str_data3, dst_str_data3, count3)
    }

Label(:EndCopy)
    # String is supposed to be a constant object, so all its data should be visible by all threads
    Intrinsic(:DATA_MEMORY_BARRIER_FULL).void
    Return(new_str).ptr

LabelGlobal(:SlowPathEntrypoint)
    if cgmode == :NativePlus
      Return(Call(str1_orig, str2_orig, str3_orig).Method('CoreStringConcat3').ptr).ptr
    else
      ep_offset = get_entrypoint_offset("STRING_CONCAT3_SLOW_PATH")
      Intrinsic(:SLOW_PATH_ENTRY, str1_orig, str2_orig, str3_orig).AddImm(ep_offset).MethodAsImm("StringConcat3OddSavedBridge").Terminator.ptr
      Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
    end
}
end

GenerateStringConcat3Tlab(:FastPath)
GenerateStringConcat3Tlab(:NativePlus)

def GenerateStringConcat4Tlab(cgmode)
  function("StringConcat4Tlab#{(cgmode == :NativePlus ? 'NativePlus' : '')}".to_sym,
           params: {str1_orig: 'ref', str2_orig: 'ref', str3_orig: 'ref', str4_orig: 'ref'},
           regmap: $full_regmap,
           regalloc_set: $panda_mask,
           mode: [cgmode]) {
    if Options.arch == :arm32
      Intrinsic(:UNREACHABLE).void.Terminator
      next
    end

    str1 := try_use_cached_flat_str_reject_sliced(str1_orig, AsGlobalLabel(:SlowPathEntrypoint))
    str2 := try_use_cached_flat_str_reject_sliced(str2_orig, AsGlobalLabel(:SlowPathEntrypoint))
    str3 := try_use_cached_flat_str_reject_sliced(str3_orig, AsGlobalLabel(:SlowPathEntrypoint))
    str4 := try_use_cached_flat_str_reject_sliced(str4_orig, AsGlobalLabel(:SlowPathEntrypoint))

    length1 := LoadI(str1).Imm(Constants::STRING_LENGTH_OFFSET).u32
    length2 := LoadI(str2).Imm(Constants::STRING_LENGTH_OFFSET).u32
    length3 := LoadI(str3).Imm(Constants::STRING_LENGTH_OFFSET).u32
    length4 := LoadI(str4).Imm(Constants::STRING_LENGTH_OFFSET).u32

    # any of the strings is uncompressed (resulted string is uncompressed)
    has_uncompressed := Or(length3, Or(length1, length2).u32).u32
    has_uncompressed := is_string_uncompressed_u32(Or(length4, has_uncompressed).u32)

    count1 := ShrI(length1).Imm(Constants::STRING_LENGTH_SHIFT).u32
    count2 := ShrI(length2).Imm(Constants::STRING_LENGTH_SHIFT).u32
    count3 := ShrI(length3).Imm(Constants::STRING_LENGTH_SHIFT).u32
    count4 := ShrI(length4).Imm(Constants::STRING_LENGTH_SHIFT).u32

    size := Add(count1, Add(count2, Add(count3, count4).u32).u32).u32
    data_size := Shl(size, has_uncompressed).u32
    length := Or(ShlI(size).Imm(Constants::STRING_LENGTH_SHIFT).u32, has_uncompressed).u32
    new_str := allocate_string_tlab(load_core_string_class(), data_size, cgmode)

    StoreI(new_str, length).Imm(Constants::STRING_LENGTH_OFFSET).u32
    StoreI(new_str, Cast(0).u32).Imm(Constants::STRING_HASHCODE_OFFSET).u32

    src_str_data1 := AddI(str1).Imm(Constants::STRING_DATA_OFFSET).ptr
    dst_str_data1 := AddI(new_str).Imm(Constants::STRING_DATA_OFFSET).ptr

    offset1 := ShlI(count1).Imm(1).u32
    offset2 := Add(offset1, ShlI(count2).Imm(1).u32).u32
    offset3 := Add(offset2, ShlI(count3).Imm(1).u32).u32

    # has no uncompressed then everything is compressed, data is stored as bytes
    If(has_uncompressed, 0).EQ.b {
      copy_u8_chars(src_str_data1, dst_str_data1, count1)

      offset1_ := ShrI(offset1).Imm(1).u32

      src_str_data2 := AddI(str2).Imm(Constants::STRING_DATA_OFFSET).ptr
      dst_str_data2 := Add(AddI(new_str).Imm(Constants::STRING_DATA_OFFSET).ptr, offset1_).ptr
      copy_u8_chars(src_str_data2, dst_str_data2, count2)

      offset2_ := ShrI(offset2).Imm(1).u32

      src_str_data3 := AddI(str3).Imm(Constants::STRING_DATA_OFFSET).ptr
      dst_str_data3 := Add(AddI(new_str).Imm(Constants::STRING_DATA_OFFSET).ptr, offset2_).ptr
      copy_u8_chars(src_str_data3, dst_str_data3, count3)

      offset3_ := ShrI(offset3).Imm(1).u32

      src_str_data4 := AddI(str4).Imm(Constants::STRING_DATA_OFFSET).ptr
      dst_str_data4 := Add(AddI(new_str).Imm(Constants::STRING_DATA_OFFSET).ptr, offset3_).ptr
      copy_u8_chars(src_str_data4, dst_str_data4, count4)
      Goto(:EndCopy)
    }

    If(is_string_uncompressed_u32(length1), 0).EQ.b {
      expand_u8_to_u16_chars(src_str_data1, dst_str_data1, count1)
    } Else {
      copy_u16_chars(src_str_data1, dst_str_data1, count1)
    }

    src_str_data2 := AddI(str2).Imm(Constants::STRING_DATA_OFFSET).ptr
    dst_str_data2 := Add(AddI(new_str).Imm(Constants::STRING_DATA_OFFSET).ptr, offset1).ptr

    If(is_string_uncompressed_u32(length2), 0).EQ.b {
      expand_u8_to_u16_chars(src_str_data2, dst_str_data2, count2)
    } Else {
      copy_u16_chars(src_str_data2, dst_str_data2, count2)
    }

    src_str_data3 := AddI(str3).Imm(Constants::STRING_DATA_OFFSET).ptr
    dst_str_data3 := Add(AddI(new_str).Imm(Constants::STRING_DATA_OFFSET).ptr, offset2).ptr

    If(is_string_uncompressed_u32(length3), 0).EQ.b {
      expand_u8_to_u16_chars(src_str_data3, dst_str_data3, count3)
    } Else {
      copy_u16_chars(src_str_data3, dst_str_data3, count3)
    }

    src_str_data4 := AddI(str4).Imm(Constants::STRING_DATA_OFFSET).ptr
    dst_str_data4 := Add(AddI(new_str).Imm(Constants::STRING_DATA_OFFSET).ptr, offset3).ptr

    If(is_string_uncompressed_u32(length4), 0).EQ.b {
      expand_u8_to_u16_chars(src_str_data4, dst_str_data4, count4)
    } Else {
      copy_u16_chars(src_str_data4, dst_str_data4, count4)
    }
Label(:EndCopy)
    # String is supposed to be a constant object, so all its data should be visible by all threads
    Intrinsic(:DATA_MEMORY_BARRIER_FULL).void
    Return(new_str).ptr

LabelGlobal(:SlowPathEntrypoint)
    if cgmode == :NativePlus
      Return(Call(str1_orig, str2_orig, str3_orig, str4_orig).Method('CoreStringConcat4').ptr).ptr
    else
      ep_offset = get_entrypoint_offset("STRING_CONCAT4_SLOW_PATH")
      Intrinsic(:SLOW_PATH_ENTRY, str1_orig, str2_orig, str3_orig, str4_orig).AddImm(ep_offset).MethodAsImm("StringConcat4UsualBridge").Terminator.ptr
      Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
    end
}
end

GenerateStringConcat4Tlab(:FastPath)
GenerateStringConcat4Tlab(:NativePlus)

###
# StringConcat2 supporting all string types
#
function(:StringConcat2TlabAllStrings,
          params: {str1: 'ref', str2: 'ref'},
          regmap: $full_regmap,
          regalloc_set: $panda_mask,
          mode: [:FastPath]) {

  if Options.arch == :arm32
    Intrinsic(:UNREACHABLE).void.Terminator
    next
  end

  # Handle empty string cases
  length1 := LoadI(str1).Imm(Constants::STRING_LENGTH_OFFSET).u32
  count1 := ShrI(length1).Imm(Constants::STRING_LENGTH_SHIFT).u32
  IfImm(Compare(count1, 0).EQ.b).Imm(0).NE.Unlikely.b {
    Return(Cast(str2).SrcType(Constants::COMPILER_REFERENCE).ptr).ptr
  }
  length2 := LoadI(str2).Imm(Constants::STRING_LENGTH_OFFSET).u32
  count2 := ShrI(length2).Imm(Constants::STRING_LENGTH_SHIFT).u32
  IfImm(Compare(count2, 0).EQ.b).Imm(0).NE.Unlikely.b {
    Return(Cast(str1).SrcType(Constants::COMPILER_REFERENCE).ptr).ptr
  }

  size := Add(count1, count2).u32
  # Create LineString if size is small enough
  If(size, Cast(Constants::TREE_STRING_MIN_LENGTH).u32).LE.b {
    LiveOut(str1).DstReg(regmap[:arg0]).ref
    LiveOut(str2).DstReg(regmap[:arg1]).ref
    ep_offset = get_entrypoint_offset("STRING_CONCAT2_TLAB")
    Intrinsic(:TAIL_CALL).AddImm(ep_offset).MethodAsImm("StringConcat2Tlab").Terminator.ptr
  }

  # Create TreeString
  ptypes := getPlatformTypes()
  klass := getTreeStringClass(ptypes)
  tree_str := allocate_tree_string_tlab(klass)

  # Any of the strings is uncompressed (resulted string is uncompressed)
  has_uncompressed := is_string_uncompressed_u32(Or(length1, length2).u32)
  length := Or(ShlI(size).Imm(Constants::STRING_LENGTH_SHIFT).u32, has_uncompressed).u32

  StoreI(tree_str, length).Imm(Constants::STRING_LENGTH_OFFSET).u32
  StoreI(tree_str, Cast(0).u32).Imm(Constants::STRING_HASHCODE_OFFSET).u32

  # It is new object, previous reference value is null, PRE write barrier is not required.
  # Object is allocated in young generation. POST write barrier is not required.
  StoreI(tree_str, str1).Imm(Constants::TREE_STRING_LEFT_OFFSET).SetNeedBarrier(false).ref
  StoreI(tree_str, str2).Imm(Constants::TREE_STRING_RIGHT_OFFSET).SetNeedBarrier(false).ref

  # String is supposed to be a constant object, so all its data should be visible by all threads
  Intrinsic(:DATA_MEMORY_BARRIER_FULL).void
  Return(tree_str).ptr

Label(:SlowPathEntrypoint)
    ep_offset = get_entrypoint_offset("STRING_CONCAT2_SLOW_PATH")
    Intrinsic(:SLOW_PATH_ENTRY, str1, str2).AddImm(ep_offset).MethodAsImm("StringConcat2UsualBridge").Terminator.ptr
    Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
}

function(:StringCharAt,
        params: {strOrig: 'ref', indexOrig: 'i32'},
        regmap: $full_regmap,
        regalloc_set: $panda_mask,
        mode: [:FastPath]) {

  if Options.arch == :arm32
    Intrinsic(:UNREACHABLE).Terminator.void
    next
  end

  check_not_tree_string_type(strOrig) if defines.DEBUG

  baseClass := load_class(strOrig)
  stringType := LoadI(baseClass).Imm(Constants::STRING_TYPE_OFFSET).u64
  If(stringType, Constants::STRING_TYPE_SLICE).EQ {
    parentStr := LoadI(strOrig).Imm(Constants::SLICED_STRING_PARENT_OFFSET).SetNeedBarrier(true).ref
    startIndexAndFlags := LoadI(strOrig).Imm(Constants::SLICED_STRING_STARTINDEX_AND_FLAGS_OFFSET).i32
    startIndex := ShrI(startIndexAndFlags).Imm(Constants::SLICED_STRING_STARTINDEX_SHIFT).i32
    slicedIndex := Add(startIndex, indexOrig).i32
  }

  str := Phi(strOrig, parentStr).ref
  index := Phi(indexOrig, slicedIndex).i32

  lengthPacked := LoadI(str).Imm(Constants::STRING_LENGTH_OFFSET).u32
  length := ShrI(lengthPacked).Imm(Constants::STRING_LENGTH_SHIFT).i32

  If(index, length).GE.b {
    Goto(:SlowPathEntrypoint)
  }

  Return(LoadCompressedStringChar(str, index, lengthPacked).u16).u16

Label(:SlowPathEntrypoint)
  entrypoint = get_entrypoint_offset("STRING_CHAR_AT_SLOW_PATH")
  Intrinsic(:SLOW_PATH_ENTRY, strOrig, indexOrig).AddImm(entrypoint).MethodAsImm("StringCharAtUsualBridge").Terminator.u16
  Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
}

def GenerateSubstringFromStringTlab(all_strings_enabled, string_compression_enabled, cgmode = :FastPath)
  suffix = (all_strings_enabled ? 'AllStrings' : '')
  suffix += (string_compression_enabled ? 'Compressed' : '')
  suffix += (cgmode == :NativePlus ? 'NativePlus' : '')
  available_regs = $panda_mask
  function("SubStringFromStringTlab#{suffix}".to_sym,
           params: {str_orig: 'ref', begin_index: 'i32', end_index: 'i32'},
           regmap: $full_regmap,
           regalloc_set: available_regs,
           mode: [cgmode]) {

    if Options.arch == :arm32
      Intrinsic(:UNREACHABLE).Terminator.void
      ReturnVoid().void
      next
    end

    if cgmode == :NativePlus
      str := try_use_cached_flat_str_reject_sliced(str_orig, AsGlobalLabel(:SlowPathEntrypoint))
    else
      check_not_tree_string_type(str_orig) if defines.DEBUG
      str := str_orig
    end

    # Note, 'str' is checked against nullptr in the InstBuilder (see AddArgNullcheckIfNeeded)
    length_packed := LoadI(str).Imm(Constants::STRING_LENGTH_OFFSET).u32
    if string_compression_enabled
      length := ShrI(length_packed).Imm(Constants::STRING_LENGTH_SHIFT).u32
    else
      length := length_packed
    end

    # If begin_index < 0, then it is assumed to be equal to zero
    If(begin_index, Cast(0).i32).LT.Unlikely.b {
      bx1 := Cast(0).i32
    }
    bx2 := Phi(begin_index, bx1).u32
    # If end_index < 0, then it is assumed to be equal to zero
    If(end_index, Cast(0).i32).LT.Unlikely.b {
      ex1 := Cast(0).i32
    }
    ex2 := Phi(end_index, ex1).u32
    # If begin_index > str.length(), then make it equal to str.length()
    If(bx2, length).A.Unlikely.b {
      bx3 := length
    }
    bx4 := Phi(bx2, bx3).u32
    # If end_index > str.length(), then make it equal to str.length()
    If(ex2, length).A.Unlikely.b {
      ex3 := length
    }
    ex4 := Phi(ex2, ex3).u32
    # If begin_index > end_index, then swap them.
    If(bx4, ex4).GT.Unlikely.b {
      bx5 := ex4
      ex5 := bx4
    }
    bx6 := Phi(bx4, bx5).u32
    ex6 := Phi(ex4, ex5).u32

    charCount := Sub(ex6, bx6).u32

    If(charCount, length).EQ.Unlikely.b {
      Return(Cast(str).SrcType(Constants::COMPILER_REFERENCE).ptr).ptr
    }

    if string_compression_enabled
      uncompressed := is_string_uncompressed_u32(length_packed)
      offset := Shl(bx6, uncompressed).u32
    else
      uncompressed := Cast(1).u32
      offset := ShlI(bx6).Imm(1).u32
    end

    # NativePlus is not yet supported for unified strings
    if all_strings_enabled && cgmode == :FastPath
      baseClass := load_class(str)
      stringType := LoadI(baseClass).Imm(Constants::STRING_TYPE_OFFSET).u64

      If(stringType, Constants::STRING_TYPE_SLICE).EQ {
        strParent := LoadI(str).Imm(Constants::SLICED_STRING_PARENT_OFFSET).SetNeedBarrier(true).ref
        strStartIndexAndBits := LoadI(str).Imm(Constants::SLICED_STRING_STARTINDEX_AND_FLAGS_OFFSET).u32
        strStartIndex := ShrI(strStartIndexAndBits).Imm(Constants::SLICED_STRING_STARTINDEX_SHIFT).u32
        addedStartIndex := Add(bx6, strStartIndex).u32
      }

      fromStr := Phi(str, strParent).ref
      resultStartIndex := Phi(bx6, addedStartIndex).u32

      If(charCount, Constants::SLICED_STRING_MIN_LENGTH).GE.b {
        Goto(:CreateSlicedString)
      }

      # create line substring from line string
      result := fast_substring(fromStr, length, resultStartIndex, charCount, uncompressed, cgmode)
      Return(result).ptr

    Label(:CreateSlicedString)
      ptypes := getPlatformTypes()
      klass := getSlicedStringClass(ptypes)
      result := allocate_sliced_string_tlab(klass)

      slicedStringLength := Or(ShlI(charCount).Imm(Constants::STRING_LENGTH_SHIFT).u32, uncompressed).u32
      StoreI(result, slicedStringLength).Imm(Constants::STRING_LENGTH_OFFSET).u32
      StoreI(result, Cast(0).u32).Imm(Constants::STRING_HASHCODE_OFFSET).u32

      # It is new object, previous reference value is null, PRE write barrier is not required.
      # Object is allocated in young generation. POST write barrier is not required.
      StoreI(result, fromStr).Imm(Constants::SLICED_STRING_PARENT_OFFSET).SetNeedBarrier(false).ref
      # hasBackingStoreBit become zero after shift left
      startIndexAndBits := ShlI(resultStartIndex).Imm(Constants::SLICED_STRING_STARTINDEX_SHIFT).u32
      StoreI(result, startIndexAndBits).Imm(Constants::SLICED_STRING_STARTINDEX_AND_FLAGS_OFFSET).u32

      # String is supposed to be a constant object, so all its data should be visible by all threads
      Intrinsic(:DATA_MEMORY_BARRIER_FULL).void

      Return(result).ptr
    else
      result := fast_substring(str, length, bx6, charCount, uncompressed, cgmode)
      Return(result).ptr
    end
LabelGlobal(:SlowPathEntrypoint)
  if cgmode == :NativePlus
    # even though it technically technically belongs to the core part
    # the ETS plugin is always present, so, we can refer to it (right?)_
    Return(Call(str_orig, begin_index, end_index).Method('SubStringFromStringEntrypoint').ptr).ptr
  else
    entrypoint = get_entrypoint_offset('SUB_STRING_FROM_STRING_SLOW_PATH')
    Intrinsic(:SLOW_PATH_ENTRY, str_orig, begin_index, end_index).AddImm(entrypoint).MethodAsImm('SubStringFromStringOddSavedBridge').Terminator.ptr
    Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
  end
  }
end  # def GenerateSubstringFromStringTlab

GenerateSubstringFromStringTlab(all_strings_enabled=false, string_compression_enabled=true)
GenerateSubstringFromStringTlab(all_strings_enabled=false, string_compression_enabled=false)
GenerateSubstringFromStringTlab(all_strings_enabled=true, string_compression_enabled=true)
GenerateSubstringFromStringTlab(all_strings_enabled=true, string_compression_enabled=false)
GenerateSubstringFromStringTlab(all_strings_enabled=false, string_compression_enabled=true, :NativePlus)
GenerateSubstringFromStringTlab(all_strings_enabled=true, string_compression_enabled=true, :NativePlus)


###
# char_to_#{tocase}_case converts a basic-latin char to the upper case by the simplest rule applicable for ASCII
# chars only.
#
[["upper", 0x61, 0x7a], ["lower", 0x41, 0x5a]].each do |tocase, min, max|
  scoped_macro("char_to_#{tocase}_case".to_sym) do |char|
    IfImm(Compare(SubI(char).Imm(min).u8, (max - min + 0x1)).B.b).Imm(0).NE.b {
      new_char1 := XorI(char).Imm(Constants::CHAR_FLIP_CASE_BIT).u8
    }
    new_char0 := char
    Phi(new_char0, new_char1).u8
  end  # char_to_#{tocase}_case
end

###
# chars_to_#{tocase}_case_8 converts 8 latin chars to the upper/lower case using the corresponding shift operations.
#
["upper", "lower"].each do |tocase|
  scoped_macro("chars_to_#{tocase}_case_8".to_sym) do |chars|
    char := u64tou8(ShrI(chars).Imm(8 * 7).u64)
    new_chars := eval("u8tou64(char_to_#{tocase}_case(char))")
    (6 * 8).step(8, -8) do |shift|
      char := u64tou8(AndI(ShrI(chars).Imm("#{shift}").u64).Imm(Constants::SINGLE_U8_MASK).u64)
      new_char := eval("u8tou64(char_to_#{tocase}_case(char))")
      new_chars := Or(ShlI(new_chars).Imm(Constants::MEM_BLOCK_8_BYTES).u64, new_char).u64
    end
    char := u64tou8(AndI(chars).Imm(Constants::SINGLE_U8_MASK).u64)
    new_char := eval("u8tou64(char_to_#{tocase}_case(char))")
    Or(ShlI(new_chars).Imm(Constants::MEM_BLOCK_8_BYTES).u64, new_char).u64
  end  # chars_to_#{tocase}_case_8
end

###
# locale_code returns a locale code built from two ASCII chars as a little-endian u16 immediate.
#
macro(:locale_code) do |code|
   "uint16_t(((uint16_t('#{code.chars[1]}') << 8) & 0xff00) | uint16_t('#{code.chars[0]}'))"
end  # locale_code

###
# locale_disallows_fast_case When the locale with code `code` doesn't support the fast case conversion,
# a jump to the `slowpath` label is emitted.
#
scoped_macro(:locale_disallows_fast_case) do |code, expected, slowpath|
  IfImm(Compare(code, locale_code(expected)).EQ.b).Imm(0).NE {
    GotoGlobal(slowpath)
  }
end  # locale_disallows_fast_case

###
# check_locale_supports_fast_latin_conversion checks whether the locale supports fast conversion between two different
# cases of latin symbols, i.e., the Turkish locale contains a conversion rule 'i -> , I -> ' what means it doesn't
# support the fast conversion. When the locale doesn't support the fast conversion, the control flow jumps to the
# `slowpath` label.
#
# One must be sure that `locale` points to the compressed flat string with the length not less than 2 and the string
# contains the locale code, e.g., "en-US" or "de".
#
# The list of the disallowed locales must be in align with the 'ark::ets::intrinsics::LocaleAllowsFastLatinConversion'
# method from the 'plugins/ets/runtime/intrinsics/helpers/ets_string_case_conversion.cpp' file.
#
scoped_macro(:check_locale_supports_fast_latin_conversion) do |locale, slowpath|
  code := LoadI(locale).Imm(Constants::STRING_DATA_OFFSET).u16
  ['az', 'tr'].each do |lang|
    locale_disallows_fast_case(code, lang, slowpath)
  end
end  # check_locale_supports_fast_latin_conversion

###
# check_default_locale_supports_fast_latin_conversion checks whether the default locale supports fast conversion between
# two different cases of latin symbols, see the comment to the 'check_locale_supports_fast_latin_conversion'.
scoped_macro(:check_default_locale_supports_fast_latin_conversion) do |cgmode, slowpath|
  if cgmode == :NativePlus
    If(Call().Method("EtsDefaultLocaleAllowsFastLatinCaseConversion").u8, 0).EQ.Unlikely {
      GotoGlobal(slowpath)
    }
  else
    # For FastPath, the check must be performed before calling the corresponding function - the macro user.
  end
end  # check_default_locale_supports_fast_latin_conversion

def GenerateStringToCaseTlab(with_locale, tocase, cgmode = :FastPath)
  need_locale = (with_locale ? "Locale" : "")
  param_tuple = (with_locale ? {orig_str: 'ref', orig_locale: 'ref'}
                             : {orig_str: 'ref'})
  suffix = (cgmode == :NativePlus ? 'NativePlus': '')
  case tocase
    when "lower"
      chars_converter = "chars_to_lower_case_8"
    when "upper"
      chars_converter = "chars_to_upper_case_8"
    else
      raise "Unexpected tocase argument: #{tocase}, only 'lower'- and 'upper'-case conversions are supported."
  end
  available_regs = $panda_mask
  function("StringTo#{need_locale}#{tocase.capitalize}CaseTlab#{suffix}".to_sym,
            params: param_tuple,
            regmap: $full_regmap,
            regalloc_set: available_regs,
            mode: [cgmode]) {

    if Options.arch == :arm32
      Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
      ReturnVoid().void
      next
    end

    # There is no check of the argument against NullPointer as
    # it's done in the InstBuilder (see AddArgNullcheckIfNeeded)
    if cgmode == :NativePlus
      str := try_use_cached_flat_str_reject_sliced(orig_str, AsGlobalLabel(:SlowPathEntrypoint))
    else
      check_not_tree_string_type(orig_str) if defines.DEBUG
      # it still can be slice
      check_string_type(orig_str, AsGlobalLabel(:SlowPathEntrypoint))
      str := orig_str
    end
    length := LoadI(str).Imm(Constants::STRING_LENGTH_OFFSET).u32
    uncompressed := is_string_uncompressed_u32(length);
    If(uncompressed, 0).NE.Unlikely {
      Goto(:SlowPathEntrypoint)
    }

    if with_locale
      if cgmode == :NativePlus
        locale := try_use_cached_flat_str_reject_sliced(orig_locale, AsGlobalLabel(:SlowPathEntrypoint))
      else
        check_not_tree_string_type(orig_locale) if defines.DEBUG
        # it still can be slice
        check_string_type(orig_locale, AsGlobalLabel(:SlowPathEntrypoint))
        locale := orig_locale
      end

      locale_length := LoadI(locale).Imm(Constants::STRING_LENGTH_OFFSET).u32
      If(is_string_uncompressed_u32(locale_length), 0).NE.Unlikely {
        Goto(:SlowPathEntrypoint)
      }
        # we are sure the locale is compressed
      If(get_string_length(Cast(locale_length).u64, Constants::STRING_LENGTH_SHIFT), 2).B.Unlikely {
        Goto(:SlowPathEntrypoint)
      }
      check_locale_supports_fast_latin_conversion(locale, AsGlobalLabel(:SlowPathEntrypoint))
    else
      check_default_locale_supports_fast_latin_conversion(cgmode, AsGlobalLabel(:SlowPathEntrypoint))
    end

    klass := load_class(str)
    # we are sure the string is compressed, the size in bytes is equal to its length
    data_size := get_string_length(Cast(length).u64, Constants::STRING_LENGTH_SHIFT)
    new_str := allocate_string_tlab(klass, Cast(data_size).word, cgmode)
    StoreI(new_str, length).Imm(Constants::STRING_LENGTH_OFFSET).u32
    StoreI(new_str, Cast(0).u32).Imm(Constants::STRING_HASHCODE_OFFSET).u32

    # Convert string data to upper/lower case
    src_str_data := AddI(reftoptr(str)).Imm(Constants::STRING_DATA_OFFSET).ptr
    dst_str_data := AddI(new_str).Imm(Constants::STRING_DATA_OFFSET).ptr
    if defines.DEBUG
      If(AndI(Bitcast(src_str_data).word).Imm(Constants::MEM_BLOCK_8_ALIGN_CHECK_MASK).word, 0).NE.Unlikely {
        Intrinsic(:UNREACHABLE).Terminator.void
      }
    end
    # Now we are sure that the string data are aligned by 8 bytes as well as any new allocated string so that
    # we may process the chars in chunks. It makes no sense if we touch the padding; moreover, the padding bytes will
    # remain intact if they contains zeros.
    offs0 := Cast(0).word
  Label(:TransformLoop_8b)
    offs := Phi(offs0, offs1).word
    new_chars := eval("#{chars_converter}(Load(src_str_data, offs).u64)")
    Store(dst_str_data, offs, new_chars).u64
    offs1 := AddI(offs).Imm(8).word
    If(offs1, data_size).B.Likely.b {
      Goto(:TransformLoop_8b)
    }

    # String is supposed to be a constant object, so all its data should be visible by all threads
    Intrinsic(:DATA_MEMORY_BARRIER_FULL).void
    Return(new_str).ptr

  LabelGlobal(:SlowPathEntrypoint)
    if with_locale
      if cgmode == :NativePlus
        Return(Call(orig_str, orig_locale).Method("StdCoreStringToLocale#{tocase.capitalize}Case").ptr).ptr
      else
        entrypoint = get_entrypoint_offset("STRING_TO_LOCALE_#{tocase.upcase}_CASE_SLOW_PATH")
        Intrinsic(:SLOW_PATH_ENTRY, orig_str, orig_locale).AddImm(entrypoint).MethodAsImm("StringToLocale#{tocase.capitalize}CaseUsualBridge").Terminator.ptr
        Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
      end
    else
      if cgmode == :NativePlus
        Return(Call(orig_str).Method("StdCoreStringTo#{tocase.capitalize}Case").ptr).ptr
      else
        entrypoint = get_entrypoint_offset("STRING_TO_#{tocase.upcase}_CASE_SLOW_PATH")
        Intrinsic(:SLOW_PATH_ENTRY, orig_str).AddImm(entrypoint).MethodAsImm("StringTo#{tocase.capitalize}CaseOddSavedBridge").Terminator.ptr
        Intrinsic(:UNREACHABLE).Terminator.void if defines.DEBUG
      end
    end
  }
end  # def GenerateStringToCaseTlab

GenerateStringToCaseTlab(with_locale = false, tocase = "upper", :FastPath)
GenerateStringToCaseTlab(with_locale = false, tocase = "upper", :NativePlus)
GenerateStringToCaseTlab(with_locale = false, tocase = "lower", :FastPath)
GenerateStringToCaseTlab(with_locale = false, tocase = "lower", :NativePlus)
GenerateStringToCaseTlab(with_locale = true, tocase = "upper", :FastPath)
GenerateStringToCaseTlab(with_locale = true, tocase = "upper", :NativePlus)
GenerateStringToCaseTlab(with_locale = true, tocase = "lower", :FastPath)
GenerateStringToCaseTlab(with_locale = true, tocase = "lower", :NativePlus)
