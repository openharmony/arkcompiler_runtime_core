# Copyright (c) 2026 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

cases:
  # Note: each 'check_variant_decl_data'
  # define different types A (TypeA) and B (TypeB) combinations
  # based on user-defined types for check values of type A & B
  # which are part of type A | B
  - check_variant_decl_data: |-
      // TypeA: I
      // TypeB: A
      // B<:A (B<:TypeB) and B<:I (B<:TypeA)
      // C<:A (C<:TypeB)
      // D<:I (D<:TypeA)

      interface I {
        methI(): string
      }

      class A {
        methA() {
          return 'methA'
        }
      }

      class B extends A implements I {
        methI() {
          return 'methIB'
        }
      }

      class C extends A {
        methC() {
          return 'methC'
        }
      }

      class D implements I {
        methI() {
          return 'methID'
        }
      }

      type TypeA = I
      type TypeB = A

      // VarType is type of v variable after branching on
      // "v instanceof A" and "v instanceof B"
      enum VarType {A_inter_B, A_diff_B, B_diff_A}
      type CheckValueFuncTypeA = (v: TypeA, v_id: int) => void
      type CheckValueFuncTypeB = (v: TypeB, v_id: int) => void
      type CheckValueData = [
        TypeA | TypeB, // value
        // check value function if VarType is A_inter_B
        CheckValueFuncTypeA | undefined,
        // check value function if VarType is A_inter_B
        CheckValueFuncTypeB | undefined,
        VarType // value_type
      ]

      // Checks value of B class instance as value of TypeA & TypeB
      // that should be assignable to TypeA
      function check_B_as_TypeA(v: TypeA) {
        if (v instanceof B) {
          arktest.assertEQ(v.methI(), 'methIB')
          arktest.assertEQ(v.methA(), 'methA')
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of B')
        }
      }

      // Checks value of B class instance as value of TypeA & TypeB
      // that should be assignable to TypeB
      function check_B_as_TypeB(v: TypeB) {
        if (v instanceof B) {
          arktest.assertEQ(v.methI(), 'methIB')
          arktest.assertEQ(v.methA(), 'methA')
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of B')
        }
      }

      let check_values: ReadonlyArray<CheckValueData> = [
        [new B(), check_B_as_TypeA, check_B_as_TypeB, VarType.A_inter_B],
        [new D(), undefined, undefined, VarType.A_diff_B],
        [new C(), undefined, undefined, VarType.B_diff_A] ]
      const check_values_number: int = 3
    check_value_type_A_inter_B_by_expression_as_TypeA:
      "arktest.assertEQ(v.methI(), 'methIB')"
    check_value_type_A_inter_B_by_expression_as_TypeB:
      "arktest.assertEQ(v.methA(), 'methA')"

  - check_variant_decl_data: |-
      // TypeA: I
      // TypeB: A
      // B<:A (B<:TypeB) and B<:I (B<:TypeA)
      // C<:A (C<:TypeB)
      // D<:I (D<:TypeA)

      interface I {
        methI(): string {
          return 'methI'
        }
      }

      abstract class A {
        abstract methA(): string
      }

      class B extends A implements I {
        methA() {
          return 'methAB'
        }
      }

      class C extends A {
        methA() {
          return 'methAC'
        }
        methC() {
          return 'methC'
        }
      }

      class D implements I {
        methD() {
          return 'methD'
        }
      }

      type TypeA = I
      type TypeB = A

      // VarType is type of v variable after branching on
      // "v instanceof A" and "v instanceof B"
      enum VarType {A_inter_B, A_diff_B, B_diff_A}
      type CheckValueFuncTypeA = (v: TypeA, v_id: int) => void
      type CheckValueFuncTypeB = (v: TypeB, v_id: int) => void
      type CheckValueData = [
        TypeA | TypeB, // value
        // check value function if VarType is A_inter_B
        CheckValueFuncTypeA | undefined,
        // check value function if VarType is A_inter_B
        CheckValueFuncTypeB | undefined,
        VarType // value_type
      ]

      // Checks value of B class instance as value of TypeA & TypeB
      // that should be assignable to TypeA
      function check_B_as_TypeA(v: TypeA) {
        if (v instanceof B) {
          arktest.assertEQ(v.methI(), 'methI')
          arktest.assertEQ(v.methA(), 'methAB')
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of B')
        }
      }

      // Checks value of B class instance as value of TypeA & TypeB
      // that should be assignable to TypeB
      function check_B_as_TypeB(v: TypeB) {
        if (v instanceof B) {
          arktest.assertEQ(v.methI(), 'methI')
          arktest.assertEQ(v.methA(), 'methAB')
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of B')
        }
      }

      let check_values: ReadonlyArray<CheckValueData> = [
        [new B(), check_B_as_TypeA, check_B_as_TypeB, VarType.A_inter_B],
        [new D(), undefined, undefined, VarType.A_diff_B],
        [new C(), undefined, undefined, VarType.B_diff_A] ]
      const check_values_number: int = 3
    check_value_type_A_inter_B_by_expression_as_TypeA:
      "arktest.assertEQ(v.methI(), 'methI')"
    check_value_type_A_inter_B_by_expression_as_TypeB:
      "arktest.assertEQ(v.methA(), 'methAB')"

  - check_variant_decl_data: |-
      // TypeA: Cat | Dog | Frog | number
      // TypeB: number | Dog | bigint

      class Animal {}
      class Cat extends Animal {vc: string = "cat"}
      class Dog extends Animal {vd: bigint = 123n}
      class Frog extends Animal {vf: int = 5}

      type TypeA = Cat | Dog | Frog | number
      type TypeB = number | Dog | bigint

      // VarType is type of v variable after branching on
      // "v instanceof A" and "v instanceof B"
      enum VarType {A_inter_B, A_diff_B, B_diff_A}
      type CheckValueFuncTypeA = (v: TypeA, v_id: int) => void
      type CheckValueFuncTypeB = (v: TypeB, v_id: int) => void
      type CheckValueData = [
        TypeA | TypeB, // value
        // check value function if VarType is A_inter_B
        CheckValueFuncTypeA | undefined,
        // check value function if VarType is A_inter_B
        CheckValueFuncTypeB | undefined,
        VarType // value_type
      ]

      // Checks value of Dog class instance as value of TypeA & TypeB
      // that should be assignable to TypeA
      function check_Dog_as_TypeA(v: TypeA) {
        if (v instanceof Dog) {
          arktest.assertEQ(v.vd, 123n)
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of Dog')
        }
      }

      // Checks value of Dog class instance as value of TypeA & TypeB
      // that should be assignable to TypeB
      function check_Dog_as_TypeB(v: TypeB) {
        if (v instanceof Dog) {
          arktest.assertEQ(v.vd, 123n)
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of Dog')
        }
      }

      // Checks number value as value of TypeA & TypeB
      // that should be assignable to TypeA
      function check_number_as_TypeA(v: TypeA) {
        if (v instanceof number) {
          arktest.assertEQ(v, 7.8)
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of number')
        }
      }

      // Checks number value as value of TypeA & TypeB
      // that should be assignable to TypeB
      function check_number_as_TypeB(v: TypeB) {
        if (v instanceof number) {
          arktest.assertEQ(v, 7.8)
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of number')
        }
      }

      // Function for skip check value of the variable by expression
      function skip_check_value_by_expression() {
      }

      let check_values: ReadonlyArray<CheckValueData> = [
        [new Dog(), check_Dog_as_TypeA, check_Dog_as_TypeB, VarType.A_inter_B],
        [7.8, check_number_as_TypeA, check_number_as_TypeB, VarType.A_inter_B],
        [new Cat(), undefined, undefined, VarType.A_diff_B],
        [new Frog(), undefined, undefined, VarType.A_diff_B],
        [5n, undefined, undefined, VarType.B_diff_A] ]
      const check_values_number: int = 5
    check_value_type_A_inter_B_by_expression_as_TypeA:
      "skip_check_value_by_expression()"
    check_value_type_A_inter_B_by_expression_as_TypeB:
      "skip_check_value_by_expression()"

  - check_variant_decl_data: |-
      // TypeA: Animal | number
      // TypeB: number | Dog | bigint
      // Cat<:Animal
      // Dog<:Animal
      // Frog<:Animal

      class Animal {}
      class Cat extends Animal {vc: string = "cat"}
      class Dog extends Animal {vd: bigint = 123n}
      class Frog extends Animal {vf: int = 5}

      type TypeA = Animal | number
      type TypeB = number | Dog | bigint

      // VarType is type of v variable after branching on
      // "v instanceof A" and "v instanceof B"
      enum VarType {A_inter_B, A_diff_B, B_diff_A}
      type CheckValueFuncTypeA = (v: TypeA, v_id: int) => void
      type CheckValueFuncTypeB = (v: TypeB, v_id: int) => void
      type CheckValueData = [
        TypeA | TypeB, // value
        // check value function if VarType is A_inter_B
        CheckValueFuncTypeA | undefined,
        // check value function if VarType is A_inter_B
        CheckValueFuncTypeB | undefined,
        VarType // value_type
      ]

      // Checks value of Dog class instance as value of TypeA & TypeB
      // that should be assignable to TypeA
      function check_Dog_as_TypeA(v: TypeA) {
        if (v instanceof Dog) {
          arktest.assertEQ(v.vd, 123n)
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of Dog')
        }
      }

      // Checks value of Dog class instance as value of TypeA & TypeB
      // that should be assignable to TypeB
      function check_Dog_as_TypeB(v: TypeB) {
        if (v instanceof Dog) {
          arktest.assertEQ(v.vd, 123n)
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of Dog')
        }
      }

      // Checks number value as value of TypeA & TypeB
      // that should be assignable to TypeA
      function check_number_as_TypeA(v: TypeA) {
        if (v instanceof number) {
          arktest.assertEQ(v, 7.8)
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of number')
        }
      }

      // Checks number value as value of TypeA & TypeB
      // that should be assignable to TypeB
      function check_number_as_TypeB(v: TypeB) {
        if (v instanceof number) {
          arktest.assertEQ(v, 7.8)
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of number')
        }
      }

      // Function for skip check value of the variable by expression
      function skip_check_value_by_expression() {
      }

      let check_values: ReadonlyArray<CheckValueData> = [
        [new Dog(), check_Dog_as_TypeA, check_Dog_as_TypeB, VarType.A_inter_B],
        [7.8, check_number_as_TypeA, check_number_as_TypeB, VarType.A_inter_B],
        [new Cat(), undefined, undefined, VarType.A_diff_B],
        [new Frog(), undefined, undefined, VarType.A_diff_B],
        [5n, undefined, undefined, VarType.B_diff_A] ]
      const check_values_number: int = 5
    check_value_type_A_inter_B_by_expression_as_TypeA:
      "skip_check_value_by_expression()"
    check_value_type_A_inter_B_by_expression_as_TypeB:
      "skip_check_value_by_expression()"

  - check_variant_decl_data: |-
      // TypeA: Dog | number | string
      // TypeB: number | Animal | bigint
      // Cat<:Animal
      // Dog<:Animal
      // Frog<:Animal

      class Animal {}
      class Cat extends Animal {vc: string = "cat"}
      class Dog extends Animal {vd: bigint = 123n}
      class Frog extends Animal {vf: int = 5}

      type TypeA = Dog | number | string
      type TypeB = number | Animal | bigint

      // VarType is type of v variable after branching on
      // "v instanceof A" and "v instanceof B"
      enum VarType {A_inter_B, A_diff_B, B_diff_A}
      type CheckValueFuncTypeA = (v: TypeA, v_id: int) => void
      type CheckValueFuncTypeB = (v: TypeB, v_id: int) => void
      type CheckValueData = [
        TypeA | TypeB, // value
        // check value function if VarType is A_inter_B
        CheckValueFuncTypeA | undefined,
        // check value function if VarType is A_inter_B
        CheckValueFuncTypeB | undefined,
        VarType // value_type
      ]

      // Checks value of Dog class instance as value of TypeA & TypeB
      // that should be assignable to TypeA
      function check_Dog_as_TypeA(v: TypeA) {
        if (v instanceof Dog) {
          arktest.assertEQ(v.vd, 123n)
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of Dog')
        }
      }

      // Checks value of Dog class instance as value of TypeA & TypeB
      // that should be assignable to TypeB
      function check_Dog_as_TypeB(v: TypeB) {
        if (v instanceof Dog) {
          arktest.assertEQ(v.vd, 123n)
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of Dog')
        }
      }

      // Checks number value as value of TypeA & TypeB
      // that should be assignable to TypeA
      function check_number_as_TypeA(v: TypeA) {
        if (v instanceof number) {
          arktest.assertEQ(v, 7.8)
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of number')
        }
      }

      // Checks number value as value of TypeA & TypeB
      // that should be assignable to TypeB
      function check_number_as_TypeB(v: TypeB) {
        if (v instanceof number) {
          arktest.assertEQ(v, 7.8)
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of number')
        }
      }

      // Function for skip check value of the variable by expression
      function skip_check_value_by_expression() {
      }

      let check_values: ReadonlyArray<CheckValueData> = [
        [new Dog(), check_Dog_as_TypeA, check_Dog_as_TypeB, VarType.A_inter_B],
        [7.8, check_number_as_TypeA, check_number_as_TypeB, VarType.A_inter_B],
        ["abc", undefined, undefined, VarType.A_diff_B],
        [new Cat(), undefined, undefined, VarType.B_diff_A],
        [new Frog(), undefined, undefined, VarType.B_diff_A],
        [5n, undefined, undefined, VarType.B_diff_A] ]
      const check_values_number: int = 6
    check_value_type_A_inter_B_by_expression_as_TypeA:
      "skip_check_value_by_expression()"
    check_value_type_A_inter_B_by_expression_as_TypeB:
      "skip_check_value_by_expression()"

  - check_variant_decl_data: |-
      // TypeA: C1 | C2 | B2 | Other
      // TypeB: B1 | Other | bigint

      abstract class A {}
      abstract class B1 extends A {}
      class B2 extends A {vb2: bigint = 123n}
      class C1 extends B1 {vc1: int = 321}
      class C2 extends B1 {vc2: number = 6.7}
      class Other {vo: string = "other"}

      type TypeA = C1 | C2 | B2 | Other
      type TypeB = B1 | Other | bigint

      // VarType is type of v variable after branching on
      // "v instanceof A" and "v instanceof B"
      enum VarType {A_inter_B, A_diff_B, B_diff_A}
      type CheckValueFuncTypeA = (v: TypeA, v_id: int) => void
      type CheckValueFuncTypeB = (v: TypeB, v_id: int) => void
      type CheckValueData = [
        TypeA | TypeB, // value
        // check value function if VarType is A_inter_B
        CheckValueFuncTypeA | undefined,
        // check value function if VarType is A_inter_B
        CheckValueFuncTypeB | undefined,
        VarType // value_type
      ]

      // Checks value of C1 class instance as value of TypeA & TypeB
      // that should be assignable to TypeA
      function check_C1_as_TypeA(v: TypeA) {
        arktest.assertTrue(v instanceof C1)
        if (v instanceof C1) {
          arktest.assertEQ(v.vc1, 321)
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of C1')
        }
      }

      // Checks value of C1 class instance as value of TypeA & TypeB
      // that should be assignable to TypeB
      function check_C1_as_TypeB(v: TypeB) {
        arktest.assertTrue(v instanceof C1)
        if (v instanceof C1) {
          arktest.assertEQ(v.vc1, 321)
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of C1')
        }
      }

      // Checks value of C2 class instance as value of TypeA & TypeB
      // that should be assignable to TypeA
      function check_C2_as_TypeA(v: TypeA) {
        if (v instanceof C2) {
          arktest.assertEQ(v.vc2, 6.7)
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of C2')
        }
      }

      // Checks value of C2 class instance as value of TypeA & TypeB
      // that should be assignable to TypeB
      function check_C2_as_TypeB(v: TypeB) {
        if (v instanceof C2) {
          arktest.assertEQ(v.vc2, 6.7)
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of C2')
        }
      }

      // Checks value of Other class instance as value of TypeA & TypeB
      // that should be assignable to TypeA
      function check_Other_as_TypeA(v: TypeA) {
        if (v instanceof Other) {
          arktest.assertEQ(v.vo, "other")
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of Other')
        }
      }

      // Checks value of Other class instance as value of TypeA & TypeB
      // that should be assignable to TypeB
      function check_Other_as_TypeB(v: TypeB) {
        if (v instanceof Other) {
          arktest.assertEQ(v.vo, "other")
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of Other')
        }
      }

      // Function for skip check value of the variable by expression
      function skip_check_value_by_expression() {
      }

      let check_values: ReadonlyArray<CheckValueData> = [
        [new C1(), check_C1_as_TypeA, check_C1_as_TypeB, VarType.A_inter_B],
        [new C2(), check_C2_as_TypeA, check_C2_as_TypeB, VarType.A_inter_B],
        [new Other(), check_Other_as_TypeA, check_Other_as_TypeB, VarType.A_inter_B],
        [new B2(), undefined, undefined, VarType.A_diff_B],
        [5n, undefined, undefined, VarType.B_diff_A] ]
      const check_values_number: int = 5
    check_value_type_A_inter_B_by_expression_as_TypeA:
      "skip_check_value_by_expression()"
    check_value_type_A_inter_B_by_expression_as_TypeB:
      "skip_check_value_by_expression()"

  - check_variant_decl_data: |-
      // TypeA: III1 | III2 | II2
      // TypeB: II1 | bigint
      // III1<:II1
      // III2<:II1
      // C1<:III1
      // C2<:III2
      // C3<:II2

      interface A {}
      interface B {}
      interface II1 extends A, B {}
      interface II2 extends A, B {}
      interface III1 extends II1 {}
      interface III2 extends II1 {}
      class C1 implements III1 {vc1: bigint = 123n}
      class C2 implements III2 {vc2: int = 321}
      class C3 implements II2 {vc3: number = 7.8}

      type TypeA = III1 | III2 | II2
      type TypeB = II1 | bigint

      // VarType is type of v variable after branching on
      // "v instanceof A" and "v instanceof B"
      enum VarType {A_inter_B, A_diff_B, B_diff_A}
      type CheckValueFuncTypeA = (v: TypeA, v_id: int) => void
      type CheckValueFuncTypeB = (v: TypeB, v_id: int) => void
      type CheckValueData = [
        TypeA | TypeB, // value
        // check value function if VarType is A_inter_B
        CheckValueFuncTypeA | undefined,
        // check value function if VarType is A_inter_B
        CheckValueFuncTypeB | undefined,
        VarType // value_type
      ]

      // Checks value of C1 class instance as value of TypeA & TypeB
      // that should be assignable to TypeA
      function check_C1_as_TypeA(v: TypeA) {
        arktest.assertTrue(v instanceof C1)
        arktest.assertTrue(v instanceof III1)
        arktest.assertTrue(v instanceof II1)
        arktest.assertTrue(v instanceof A)
        arktest.assertTrue(v instanceof B)
        if (v instanceof C1) {
          arktest.assertEQ(v.vc1, 123n)
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of C1')
        }
      }

      // Checks value of C1 class instance as value of TypeA & TypeB
      // that should be assignable to TypeB
      function check_C1_as_TypeB(v: TypeB) {
        arktest.assertTrue(v instanceof C1)
        arktest.assertTrue(v instanceof III1)
        arktest.assertTrue(v instanceof II1)
        arktest.assertTrue(v instanceof A)
        arktest.assertTrue(v instanceof B)
        if (v instanceof C1) {
          arktest.assertEQ(v.vc1, 123n)
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of C1')
        }
      }

      // Checks value of C2 class instance as value of TypeA & TypeB
      // that should be assignable to TypeA
      function check_C2_as_TypeA(v: TypeA) {
        arktest.assertTrue(v instanceof C2)
        arktest.assertTrue(v instanceof III2)
        arktest.assertTrue(v instanceof II1)
        arktest.assertTrue(v instanceof A)
        arktest.assertTrue(v instanceof B)
        if (v instanceof C2) {
          arktest.assertEQ(v.vc2, 321)
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of C2')
        }
      }

      // Checks value of C2 class instance as value of TypeA & TypeB
      // that should be assignable to TypeB
      function check_C2_as_TypeB(v: TypeB) {
        arktest.assertTrue(v instanceof C2)
        arktest.assertTrue(v instanceof III2)
        arktest.assertTrue(v instanceof II1)
        arktest.assertTrue(v instanceof A)
        arktest.assertTrue(v instanceof B)
        if (v instanceof C2) {
          arktest.assertEQ(v.vc2, 321)
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of C2')
        }
      }

      // Function for skip check value of the variable by expression
      function skip_check_value_by_expression() {
      }

      let check_values: ReadonlyArray<CheckValueData> = [
        [new C1(), check_C1_as_TypeA, check_C1_as_TypeB, VarType.A_inter_B],
        [new C2(), check_C2_as_TypeA, check_C2_as_TypeB, VarType.A_inter_B],
        [new C3(), undefined, undefined, VarType.A_diff_B],
        [5n, undefined, undefined, VarType.B_diff_A] ]
      const check_values_number: int = 4
    check_value_type_A_inter_B_by_expression_as_TypeA:
      "skip_check_value_by_expression()"
    check_value_type_A_inter_B_by_expression_as_TypeB:
      "skip_check_value_by_expression()"

  - check_variant_decl_data: |-
      // TypeA: III1 | III2 | II2
      // TypeB: III2 | bigint
      // III1<:II1
      // III2<:II1
      // C1<:III1 and C1<:III2
      // C2<:II2 and C2<:III2
      // C3<:III1

      interface I {}
      interface II1 extends I {}
      interface II2 extends I {}
      interface III1 extends II1 {}
      interface III2 extends II1 {}
      class C1 implements III1, III2 {vc1: bigint = 123n}
      class C2 implements II2, III2 {vc2: int = 321}
      class C3 implements III1 {vc3: number = 7.8}

      type TypeA = III1 | III2 | II2
      type TypeB = III2 | bigint

      // VarType is type of v variable after branching on
      // "v instanceof A" and "v instanceof B"
      enum VarType {A_inter_B, A_diff_B, B_diff_A}
      type CheckValueFuncTypeA = (v: TypeA, v_id: int) => void
      type CheckValueFuncTypeB = (v: TypeB, v_id: int) => void
      type CheckValueData = [
        TypeA | TypeB, // value
        // check value function if VarType is A_inter_B
        CheckValueFuncTypeA | undefined,
        // check value function if VarType is A_inter_B
        CheckValueFuncTypeB | undefined,
        VarType // value_type
      ]

      // Checks value of C1 class instance as value of TypeA & TypeB
      // that should be assignable to TypeA
      function check_C1_as_TypeA(v: TypeA) {
        arktest.assertTrue(v instanceof C1)
        arktest.assertTrue(v instanceof III1)
        arktest.assertTrue(v instanceof III2)
        arktest.assertTrue(v instanceof II1)
        arktest.assertTrue(v instanceof I)
        if (v instanceof C1) {
          arktest.assertEQ(v.vc1, 123n)
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of C1')
        }
      }

      // Checks value of C1 class instance as value of TypeA & TypeB
      // that should be assignable to TypeB
      function check_C1_as_TypeB(v: TypeB) {
        arktest.assertTrue(v instanceof C1)
        arktest.assertTrue(v instanceof III1)
        arktest.assertTrue(v instanceof III2)
        arktest.assertTrue(v instanceof II1)
        arktest.assertTrue(v instanceof I)
        if (v instanceof C1) {
          arktest.assertEQ(v.vc1, 123n)
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of C1')
        }
      }

      // Checks value of C2 class instance as value of TypeA & TypeB
      // that should be assignable to TypeA
      function check_C2_as_TypeA(v: TypeA) {
        arktest.assertTrue(v instanceof C2)
        arktest.assertTrue(v instanceof II2)
        arktest.assertTrue(v instanceof III2)
        arktest.assertTrue(v instanceof II1)
        arktest.assertTrue(v instanceof I)
        if (v instanceof C2) {
          arktest.assertEQ(v.vc2, 321)
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of C2')
        }
      }

      // Checks value of C2 class instance as value of TypeA & TypeB
      // that should be assignable to TypeB
      function check_C2_as_TypeB(v: TypeB) {
        arktest.assertTrue(v instanceof C2)
        arktest.assertTrue(v instanceof II2)
        arktest.assertTrue(v instanceof III2)
        arktest.assertTrue(v instanceof II1)
        arktest.assertTrue(v instanceof I)
        if (v instanceof C2) {
          arktest.assertEQ(v.vc2, 321)
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of C2')
        }
      }

      // Function for skip check value of the variable by expression
      function skip_check_value_by_expression() {
      }

      let check_values: ReadonlyArray<CheckValueData> = [
        [new C1(), check_C1_as_TypeA, check_C1_as_TypeB, VarType.A_inter_B],
        [new C2(), check_C2_as_TypeA, check_C2_as_TypeB, VarType.A_inter_B],
        [new C3(), undefined, undefined, VarType.A_diff_B],
        [5n, undefined, undefined, VarType.B_diff_A] ]
      const check_values_number: int = 4
    check_value_type_A_inter_B_by_expression_as_TypeA:
      "skip_check_value_by_expression()"
    check_value_type_A_inter_B_by_expression_as_TypeB:
      "skip_check_value_by_expression()"
