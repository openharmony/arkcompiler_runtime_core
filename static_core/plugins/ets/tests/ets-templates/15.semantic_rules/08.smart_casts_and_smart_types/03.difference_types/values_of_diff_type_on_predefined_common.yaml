# Copyright (c) 2026 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

cases:
  # Note: each 'check_variant_decl_data'
  # define different types A and B combinations
  # based on predefined types for check values of
  # difference types A - B and B - A
  # which are part of type A | B
  - check_variant_decl_data: |-
      type A = Object | undefined
      type B = undefined | null

      // type A - B is computed smart type on the negative branch
      // after branching on "v instanceof A"
      type A_diff_B = Object

      // type B - A is computed smart type on the negative branch
      // after branching on "v instanceof B"
      type B_diff_A = null

      // VarType is type of v variable after branching on
      // "v instanceof A" and "v instanceof B"
      enum VarType {A_inter_B, A_diff_B, B_diff_A}
      type CheckValueData = [
        A | B, // value
        VarType // value_type
      ]

      let check_values: ReadonlyArray<CheckValueData> = [
        [undefined, VarType.A_inter_B],
        [5n, VarType.A_diff_B],
        [123, VarType.A_diff_B],
        ["abc", VarType.A_diff_B],
        [c'a', VarType.A_diff_B],
        [null, VarType.B_diff_A] ]
      const check_values_number: int = 6
    check_value_by_expression_as_type_A_diff_B:
      "arktest.assertTrue(v.toString().length > 0)"
    check_value_by_expression_as_type_B_diff_A:
      "arktest.assertEQ(v, null)"

  - check_variant_decl_data: |-
      type A = Object | undefined
      type B = Object | null

      // type A - B is computed smart type on the negative branch
      // after branching on "v instanceof A"
      type A_diff_B = undefined

      // type B - A is computed smart type on the negative branch
      // after branching on "v instanceof B"
      type B_diff_A = null

      // VarType is type of v variable after branching on
      // "v instanceof A" and "v instanceof B"
      enum VarType {A_inter_B, A_diff_B, B_diff_A}
      type CheckValueData = [
        A | B, // value
        VarType // value_type
      ]

      let check_values: ReadonlyArray<CheckValueData> = [
        [5n, VarType.A_inter_B],
        [123, VarType.A_inter_B],
        ["abc", VarType.A_inter_B],
        [c'a', VarType.A_inter_B],
        [undefined, VarType.A_diff_B],
        [null, VarType.B_diff_A] ]
      const check_values_number: int = 6
    check_value_by_expression_as_type_A_diff_B:
      "arktest.assertEQ(v, undefined)"
    check_value_by_expression_as_type_B_diff_A:
      "arktest.assertEQ(v, null)"

  - check_variant_decl_data: |-
      type A = Object | undefined
      type B = string | undefined | null

      // type A - B is computed smart type on the negative branch
      // after branching on "v instanceof A"
      type A_diff_B = Object // nearest supertype for A - B

      // type B - A is computed smart type on the negative branch
      // after branching on "v instanceof B"
      type B_diff_A = null

      // VarType is type of v variable after branching on
      // "v instanceof A" and "v instanceof B"
      enum VarType {A_inter_B, A_diff_B, B_diff_A}
      type CheckValueData = [
        A | B, // value
        VarType // value_type
      ]

      let check_values: ReadonlyArray<CheckValueData> = [
        ["abc", VarType.A_inter_B],
        [undefined, VarType.A_inter_B],
        [5n, VarType.A_diff_B],
        [7.8, VarType.A_diff_B],
        [123, VarType.A_diff_B],
        [5.6f, VarType.A_diff_B],
        [c'a', VarType.A_diff_B],
        [null, VarType.B_diff_A] ]
      const check_values_number: int = 8
    check_value_by_expression_as_type_A_diff_B:
      "arktest.assertTrue(v.toString().length > 0)"
    check_value_by_expression_as_type_B_diff_A:
      "arktest.assertEQ(v, null)"

  - check_variant_decl_data: |-
      type A = string | undefined | null
      type B = Object | null

      // type A - B is computed smart type on the negative branch
      // after branching on "v instanceof A"
      type A_diff_B = undefined

      // type B - A is computed smart type on the negative branch
      // after branching on "v instanceof B"
      type B_diff_A = Object // nearest supertype for B - A

      // VarType is type of v variable after branching on
      // "v instanceof A" and "v instanceof B"
      enum VarType {A_inter_B, A_diff_B, B_diff_A}
      type CheckValueData = [
        A | B, // value
        VarType // value_type
      ]

      let check_values: ReadonlyArray<CheckValueData> = [
        ["abc", VarType.A_inter_B],
        [null, VarType.A_inter_B],
        [undefined, VarType.A_diff_B],
        [5n, VarType.B_diff_A],
        [7.8, VarType.B_diff_A],
        [123, VarType.B_diff_A],
        [5.6f, VarType.B_diff_A],
        [c'a', VarType.B_diff_A] ]
      const check_values_number: int = 8
    check_value_by_expression_as_type_A_diff_B:
      "arktest.assertEQ(v, undefined)"
    check_value_by_expression_as_type_B_diff_A:
      "arktest.assertTrue(v.toString().length > 0)"

  - check_variant_decl_data: |-
      type A = int | bigint | boolean | string
      type B = string | char | bigint | float

      // type A - B is computed smart type on the negative branch
      // after branching on "v instanceof A"
      type A_diff_B = int | boolean

      // type B - A is computed smart type on the negative branch
      // after branching on "v instanceof B"
      type B_diff_A = char | float

      // VarType is type of v variable after branching on
      // "v instanceof A" and "v instanceof B"
      enum VarType {A_inter_B, A_diff_B, B_diff_A}
      type CheckValueData = [
        A | B, // value
        VarType // value_type
      ]
      let check_values: ReadonlyArray<CheckValueData> = [
        ["abc", VarType.A_inter_B],
        [5n, VarType.A_inter_B],
        [true, VarType.A_diff_B],
        [123, VarType.A_diff_B],
        [c'a', VarType.B_diff_A],
        [7.8f, VarType.B_diff_A] ]
      const check_values_number: int = 6
    check_value_by_expression_as_type_A_diff_B:
      "arktest.assertEQ(v, check_values[v_id][0])"
    check_value_by_expression_as_type_B_diff_A:
      "arktest.assertEQ(v, check_values[v_id][0])"

  - check_variant_decl_data: |-
      type A = char | int
      type B = char | string

      // type A - B is computed smart type on the negative branch
      // after branching on "v instanceof A"
      type A_diff_B = int

      // type B - A is computed smart type on the negative branch
      // after branching on "v instanceof B"
      type B_diff_A = string

      // VarType is type of v variable after branching on
      // "v instanceof A" and "v instanceof B"
      enum VarType {A_inter_B, A_diff_B, B_diff_A}
      type CheckValueData = [
        A | B, // value
        VarType // value_type
      ]

      let check_values: ReadonlyArray<CheckValueData> = [
        [c'a', VarType.A_inter_B],
        [123, VarType.A_diff_B],
        ["abc", VarType.B_diff_A] ]
      const check_values_number: int = 3
    check_value_by_expression_as_type_A_diff_B:
      "arktest.assertEQ(v.toByte(), 123 as byte)"
    check_value_by_expression_as_type_B_diff_A:
      "arktest.assertEQ(v.length, 3)"

  - check_variant_decl_data: |-
      type A = char | long
      type B = char | string

      // type A - B is computed smart type on the negative branch
      // after branching on "v instanceof A"
      type A_diff_B = long

      // type B - A is computed smart type on the negative branch
      // after branching on "v instanceof B"
      type B_diff_A = string

      // VarType is type of v variable after branching on
      // "v instanceof A" and "v instanceof B"
      enum VarType {A_inter_B, A_diff_B, B_diff_A}
      type CheckValueData = [
        A | B, // value
        VarType // value_type
      ]

      let check_values: ReadonlyArray<CheckValueData> = [
        [c'a', VarType.A_inter_B],
        [256 as long, VarType.A_diff_B],
        ["abc", VarType.B_diff_A] ]
      const check_values_number: int = 3
    check_value_by_expression_as_type_A_diff_B:
      "arktest.assertEQ(v.toInt(), 256)"
    check_value_by_expression_as_type_B_diff_A:
      "arktest.assertEQ(v.length, 3)"

  - check_variant_decl_data: |-
      type A = char | byte
      type B = char | string

      // type A - B is computed smart type on the negative branch
      // after branching on "v instanceof A"
      type A_diff_B = byte

      // type B - A is computed smart type on the negative branch
      // after branching on "v instanceof B"
      type B_diff_A = string

      // VarType is type of v variable after branching on
      // "v instanceof A" and "v instanceof B"
      enum VarType {A_inter_B, A_diff_B, B_diff_A}
      type CheckValueData = [
        A | B, // value
        VarType // value_type
      ]

      let check_values: ReadonlyArray<CheckValueData> = [
        [c'a', VarType.A_inter_B],
        [5 as byte, VarType.A_diff_B],
        ["abc", VarType.B_diff_A] ]
      const check_values_number: int = 3
    check_value_by_expression_as_type_A_diff_B:
      "arktest.assertEQ(v.toInt(), 5)"
    check_value_by_expression_as_type_B_diff_A:
      "arktest.assertEQ(v.length, 3)"

  - check_variant_decl_data: |-
      type A = char | short
      type B = char | string

      // type A - B is computed smart type on the negative branch
      // after branching on "v instanceof A"
      type A_diff_B = short

      // type B - A is computed smart type on the negative branch
      // after branching on "v instanceof B"
      type B_diff_A = string

      // VarType is type of v variable after branching on
      // "v instanceof A" and "v instanceof B"
      enum VarType {A_inter_B, A_diff_B, B_diff_A}
      type CheckValueData = [
        A | B, // value
        VarType // value_type
      ]

      let check_values: ReadonlyArray<CheckValueData> = [
        [c'a', VarType.A_inter_B],
        [128 as short, VarType.A_diff_B],
        ["abc", VarType.B_diff_A] ]
      const check_values_number: int = 3
    check_value_by_expression_as_type_A_diff_B:
      "arktest.assertEQ(v.toInt(), 128)"
    check_value_by_expression_as_type_B_diff_A:
      "arktest.assertEQ(v.length, 3)"

  - check_variant_decl_data: |-
      type A = char | double
      type B = char | string

      // type A - B is computed smart type on the negative branch
      // after branching on "v instanceof A"
      type A_diff_B = double

      // type B - A is computed smart type on the negative branch
      // after branching on "v instanceof B"
      type B_diff_A = string

      // VarType is type of v variable after branching on
      // "v instanceof A" and "v instanceof B"
      enum VarType {A_inter_B, A_diff_B, B_diff_A}
      type CheckValueData = [
        A | B, // value
        VarType // value_type
      ]

      let check_values: ReadonlyArray<CheckValueData> = [
        [c'a', VarType.A_inter_B],
        [12.43, VarType.A_diff_B],
        ["abc", VarType.B_diff_A] ]
      const check_values_number: int = 3
    check_value_by_expression_as_type_A_diff_B:
      "arktest.assertEQ(v.toInt(), 12)"
    check_value_by_expression_as_type_B_diff_A:
      "arktest.assertEQ(v.length, 3)"

  - check_variant_decl_data: |-
      type A = char | number
      type B = char | string

      // type A - B is computed smart type on the negative branch
      // after branching on "v instanceof A"
      type A_diff_B = number

      // type B - A is computed smart type on the negative branch
      // after branching on "v instanceof B"
      type B_diff_A = string

      // VarType is type of v variable after branching on
      // "v instanceof A" and "v instanceof B"
      enum VarType {A_inter_B, A_diff_B, B_diff_A}
      type CheckValueData = [
        A | B, // value
        VarType // value_type
      ]

      let check_values: ReadonlyArray<CheckValueData> = [
        [c'a', VarType.A_inter_B],
        [12.43, VarType.A_diff_B],
        ["abc", VarType.B_diff_A] ]
      const check_values_number: int = 3
    check_value_by_expression_as_type_A_diff_B:
      "arktest.assertEQ(v.toInt(), 12)"
    check_value_by_expression_as_type_B_diff_A:
      "arktest.assertEQ(v.length, 3)"

  - check_variant_decl_data: |-
      type A = char | float
      type B = char | string

      // type A - B is computed smart type on the negative branch
      // after branching on "v instanceof A"
      type A_diff_B = float

      // type B - A is computed smart type on the negative branch
      // after branching on "v instanceof B"
      type B_diff_A = string

      // VarType is type of v variable after branching on
      // "v instanceof A" and "v instanceof B"
      enum VarType {A_inter_B, A_diff_B, B_diff_A}
      type CheckValueData = [
        A | B, // value
        VarType // value_type
      ]

      let check_values: ReadonlyArray<CheckValueData> = [
        [c'a', VarType.A_inter_B],
        [12.43f, VarType.A_diff_B],
        ["abc", VarType.B_diff_A] ]
      const check_values_number: int = 3
    check_value_by_expression_as_type_A_diff_B:
      "arktest.assertEQ(v.toInt(), 12)"
    check_value_by_expression_as_type_B_diff_A:
      "arktest.assertEQ(v.length, 3)"

  - check_variant_decl_data: |-
      type A = char | bigint
      type B = char | string

      // type A - B is computed smart type on the negative branch
      // after branching on "v instanceof A"
      type A_diff_B = bigint

      // type B - A is computed smart type on the negative branch
      // after branching on "v instanceof B"
      type B_diff_A = string

      // VarType is type of v variable after branching on
      // "v instanceof A" and "v instanceof B"
      enum VarType {A_inter_B, A_diff_B, B_diff_A}
      type CheckValueData = [
        A | B, // value
        VarType // value_type
      ]

      let check_values: ReadonlyArray<CheckValueData> = [
        [c'a', VarType.A_inter_B],
        [3n, VarType.A_diff_B],
        ["abc", VarType.B_diff_A] ]
      const check_values_number: int = 3
    check_value_by_expression_as_type_A_diff_B:
      "arktest.assertEQ(v.pow(2n), 9n)"
    check_value_by_expression_as_type_B_diff_A:
      "arktest.assertEQ(v.length, 3)"

  - check_variant_decl_data: |-
      type A = number | char
      type B = number | string

      // type A - B is computed smart type on the negative branch
      // after branching on "v instanceof A"
      type A_diff_B = char

      // type B - A is computed smart type on the negative branch
      // after branching on "v instanceof B"
      type B_diff_A = string

      // VarType is type of v variable after branching on
      // "v instanceof A" and "v instanceof B"
      enum VarType {A_inter_B, A_diff_B, B_diff_A}
      type CheckValueData = [
        A | B, // value
        VarType // value_type
      ]

      let check_values: ReadonlyArray<CheckValueData> = [
        [12.47, VarType.A_inter_B],
        [c'a', VarType.A_diff_B],
        ["abc", VarType.B_diff_A] ]
      const check_values_number: int = 3
    check_value_by_expression_as_type_A_diff_B:
      "arktest.assertEQ(v.toString(), \"a\")"
    check_value_by_expression_as_type_B_diff_A:
      "arktest.assertEQ(v.length, 3)"

  - check_variant_decl_data: |-
      type A = number | boolean
      type B = number | string

      // type A - B is computed smart type on the negative branch
      // after branching on "v instanceof A"
      type A_diff_B = boolean

      // type B - A is computed smart type on the negative branch
      // after branching on "v instanceof B"
      type B_diff_A = string

      // VarType is type of v variable after branching on
      // "v instanceof A" and "v instanceof B"
      enum VarType {A_inter_B, A_diff_B, B_diff_A}
      type CheckValueData = [
        A | B, // value
        VarType // value_type
      ]

      let check_values: ReadonlyArray<CheckValueData> = [
        [12.47, VarType.A_inter_B],
        [true, VarType.A_diff_B],
        ["abc", VarType.B_diff_A] ]
      const check_values_number: int = 3
    check_value_by_expression_as_type_A_diff_B:
      "arktest.assertEQ(v.valueOf(), true)"
    check_value_by_expression_as_type_B_diff_A:
      "arktest.assertEQ(v.length, 3)"
