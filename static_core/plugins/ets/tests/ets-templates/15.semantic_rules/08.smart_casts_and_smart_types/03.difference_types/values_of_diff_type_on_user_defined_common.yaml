# Copyright (c) 2026 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

cases:
  # Note: each 'check_variant_decl_data'
  # define different types A and B combinations
  # based on user-defined types for check values of
  # difference types A - B and B - A
  # which are part of type A | B
  - check_variant_decl_data: |-
      // A: I
      // B: Base
      // F<:Base (F<:B) and F<:I (F<:A)
      // C<:Base (C<:B)
      // D<:I (D<:A)

      interface I {
        methI(): string
      }

      class Base {
        methBase() {
          return 'methBase'
        }
      }

      class F extends Base implements I {
        methI() {
          return 'methIF'
        }
      }

      class C extends Base {
        methC() {
          return 'methC'
        }
      }

      class D implements I {
        methI() {
          return 'methID'
        }
      }

      type A = I
      type B = Base

      // type A - B is computed smart type on the negative branch
      // after branching on "v instanceof A"
      type A_diff_B = I // nearest supertype for A - B

      // type B - A is computed smart type on the negative branch
      // after branching on "v instanceof B"
      type B_diff_A = Base // nearest supertype for B - A

      // VarType is type of v variable after branching on
      // "v instanceof A" and "v instanceof B"
      enum VarType {A_inter_B, A_diff_B, B_diff_A}
      type CheckValueFuncTypeA_diff_B = (v: A_diff_B, v_id: int) => void
      type CheckValueFuncTypeB_diff_A = (v: B_diff_A, v_id: int) => void
      type CheckValueData = [
        A | B, // value
        // check value function if VarType is A_diff_B
        CheckValueFuncTypeA_diff_B | undefined,
        // check value function if VarType is B_diff_A
        CheckValueFuncTypeB_diff_A | undefined,
        VarType // value_type
      ]

      // Checks value of D class instance as value of A - B
      // that should be assignable to A_diff_B
      function check_D(v: A_diff_B) {
        if (v instanceof D) {
          arktest.assertEQ(v.methI(), 'methID')
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of D')
        }
      }

      // Checks value of C class instance as value of B - A
      // that should be assignable to B_diff_A
      function check_C(v: B_diff_A) {
        if (v instanceof C) {
          arktest.assertEQ(v.methC(), 'methC')
          arktest.assertEQ(v.methBase(), 'methBase')
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of C')
        }
      }

      let check_values: ReadonlyArray<CheckValueData> = [
        [new F(), undefined, undefined, VarType.A_inter_B],
        [new D(), check_D, undefined, VarType.A_diff_B],
        [new C(), undefined, check_C, VarType.B_diff_A] ]
      const check_values_number: int = 3
    check_value_by_expression_as_type_A_diff_B:
      "arktest.assertEQ(v.methI(), 'methID')"
    check_value_by_expression_as_type_B_diff_A:
      "arktest.assertEQ(v.methBase(), 'methBase')"

  - check_variant_decl_data: |-
      // A: I
      // B: Base
      // F<:Base (F<:B) and F<:I (F<:A)
      // C<:Base (C<:B)
      // D<:I (D<:A)

      interface I {
        methI(): string {
          return 'methI'
        }
      }

      abstract class Base {
        abstract methBase(): string
      }

      class F extends Base implements I {
        methBase() {
          return 'methBaseF'
        }
      }

      class C extends Base {
        methBase() {
          return 'methBaseC'
        }
        methC() {
          return 'methC'
        }
      }

      class D implements I {
        methD() {
          return 'methD'
        }
      }

      type A = I
      type B = Base

      // type A - B is computed smart type on the negative branch
      // after branching on "v instanceof A"
      type A_diff_B = I // nearest supertype for A - B

      // type B - A is computed smart type on the negative branch
      // after branching on "v instanceof B"
      type B_diff_A = Base // nearest supertype for B - A

      // VarType is type of v variable after branching on
      // "v instanceof A" and "v instanceof B"
      enum VarType {A_inter_B, A_diff_B, B_diff_A}
      type CheckValueFuncTypeA_diff_B = (v: A_diff_B, v_id: int) => void
      type CheckValueFuncTypeB_diff_A = (v: B_diff_A, v_id: int) => void
      type CheckValueData = [
        A | B, // value
        // check value function if VarType is A_diff_B
        CheckValueFuncTypeA_diff_B | undefined,
        // check value function if VarType is B_diff_A
        CheckValueFuncTypeB_diff_A | undefined,
        VarType // value_type
      ]

      // Checks value of D class instance as value of A - B
      // that should be assignable to A_diff_B
      function check_D(v: A_diff_B) {
        if (v instanceof D) {
          arktest.assertEQ(v.methI(), 'methI')
          arktest.assertEQ(v.methD(), 'methD')
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of D')
        }
      }

      // Checks value of C class instance as value of B - A
      // that should be assignable to B_diff_A
      function check_C(v: B_diff_A) {
        if (v instanceof C) {
          arktest.assertEQ(v.methBase(), 'methBaseC')
          arktest.assertEQ(v.methC(), 'methC')
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of C')
        }
      }

      let check_values: ReadonlyArray<CheckValueData> = [
        [new F(), undefined, undefined, VarType.A_inter_B],
        [new D(), check_D, undefined, VarType.A_diff_B],
        [new C(), undefined, check_C, VarType.B_diff_A] ]
      const check_values_number: int = 3
    check_value_by_expression_as_type_A_diff_B:
      "arktest.assertEQ(v.methI(), 'methI')"
    check_value_by_expression_as_type_B_diff_A:
      "arktest.assertEQ(v.methBase(), 'methBaseC')"

  - check_variant_decl_data: |-
      // A: Cat | Dog | number
      // B: number | Dog | Frog

      class Animal {}
      class Cat extends Animal {vc: string = 'cat'}
      class Dog extends Animal {vd: bigint = 123n}
      class Frog extends Animal {vf: int = 5}

      type A = Cat | Dog | number
      type B = number | Dog | Frog

      // type A - B is computed smart type on the negative branch
      // after branching on "v instanceof A"
      type A_diff_B = Cat

      // type B - A is computed smart type on the negative branch
      // after branching on "v instanceof B"
      type B_diff_A = Frog

      // VarType is type of v variable after branching on
      // "v instanceof A" and "v instanceof B"
      enum VarType {A_inter_B, A_diff_B, B_diff_A}
      type CheckValueFuncTypeA_diff_B = (v: A_diff_B, v_id: int) => void
      type CheckValueFuncTypeB_diff_A = (v: B_diff_A, v_id: int) => void
      type CheckValueData = [
        A | B, // value
        // check value function if VarType is A_diff_B
        CheckValueFuncTypeA_diff_B | undefined,
        // check value function if VarType is B_diff_A
        CheckValueFuncTypeB_diff_A | undefined,
        VarType // value_type
      ]

      // Checks value of Cat class instance as value of A - B
      // that should be assignable to A_diff_B
      function check_Cat(v: A_diff_B) {
        arktest.assertEQ(v.vc, 'cat')
      }

      // Checks value of Frog class instance as value of B - A
      // that should be assignable to B_diff_A
      function check_Frog(v: B_diff_A) {
        arktest.assertEQ(v.vf, 5)
      }

      let check_values: ReadonlyArray<CheckValueData> = [
        [new Dog(), undefined, undefined, VarType.A_inter_B],
        [7.8, undefined, undefined, VarType.A_inter_B],
        [new Cat(), check_Cat, undefined, VarType.A_diff_B],
        [new Frog(), undefined, check_Frog, VarType.A_diff_B] ]
      const check_values_number: int = 4
    check_value_by_expression_as_type_A_diff_B:
      "arktest.assertEQ(v.vc, 'cat')"
    check_value_by_expression_as_type_B_diff_A:
      "arktest.assertEQ(v.vf, 5)"

  - check_variant_decl_data: |-
      // A: Animal | number
      // B: number | Dog | bigint
      // Cat<:Animal
      // Dog<:Animal
      // Frog<:Animal

      class Animal {va: number = 567}
      class Cat extends Animal {vc: string = "cat"}
      class Dog extends Animal {vd: bigint = 123n}
      class Frog extends Animal {vf: int = 5}

      type A = Animal | number
      type B = number | Dog | bigint

      // type A - B is computed smart type on the negative branch
      // after branching on "v instanceof A"
      type A_diff_B = Animal // nearest supertype for A - B

      // type B - A is computed smart type on the negative branch
      // after branching on "v instanceof B"
      type B_diff_A = bigint

      // VarType is type of v variable after branching on
      // "v instanceof A" and "v instanceof B"
      enum VarType {A_inter_B, A_diff_B, B_diff_A}
      type CheckValueFuncTypeA_diff_B = (v: A_diff_B, v_id: int) => void
      type CheckValueFuncTypeB_diff_A = (v: B_diff_A, v_id: int) => void
      type CheckValueData = [
        A | B, // value
        // check value function if VarType is A_diff_B
        CheckValueFuncTypeA_diff_B | undefined,
        // check value function if VarType is B_diff_A
        CheckValueFuncTypeB_diff_A | undefined,
        VarType // value_type
      ]

      // Checks value of Cat class instance as value of A - B
      // that should be assignable to A_diff_B
      function check_Cat(v: A_diff_B) {
        if (v instanceof Cat) {
          arktest.assertEQ(v.va, 567)
          arktest.assertEQ(v.vc, 'cat')
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of Cat')
        }
      }

      // Checks value of Frog class instance as value of A - B
      // that should be assignable to A_diff_B
      function check_Frog(v: A_diff_B) {
        if (v instanceof Frog) {
          arktest.assertEQ(v.va, 567)
          arktest.assertEQ(v.vf, 5)
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of Frog')
        }
      }

      // Checks bigint value as value of B - A
      // that should be assignable to B_diff_A
      function check_bigint(v: B_diff_A) {
        arktest.assertEQ(v, 3n)
      }

      let check_values: ReadonlyArray<CheckValueData> = [
        [new Dog(), undefined, undefined, VarType.A_inter_B],
        [7.8, undefined, undefined, VarType.A_inter_B],
        [new Cat(), check_Cat, undefined, VarType.A_diff_B],
        [new Frog(), check_Frog, undefined, VarType.A_diff_B],
        [3n, undefined, check_bigint, VarType.B_diff_A] ]
      const check_values_number: int = 5
    check_value_by_expression_as_type_A_diff_B:
      "arktest.assertEQ(v.va, 567)"
    check_value_by_expression_as_type_B_diff_A:
      "arktest.assertEQ(v.pow(2n), 9n)"

  - check_variant_decl_data: |-
      // A: Dog | number | string
      // B: number | Animal
      // Cat<:Animal
      // Dog<:Animal
      // Frog<:Animal

      class Animal {va: number = 567}
      class Cat extends Animal {vc: string = "cat"}
      class Dog extends Animal {vd: bigint = 123n}
      class Frog extends Animal {vf: int = 5}

      type A = Dog | number | string
      type B = number | Animal

      // type A - B is computed smart type on the negative branch
      // after branching on "v instanceof A"
      type A_diff_B = string

      // type B - A is computed smart type on the negative branch
      // after branching on "v instanceof B"
      type B_diff_A = Animal // nearest supertype for B - A

      // VarType is type of v variable after branching on
      // "v instanceof A" and "v instanceof B"
      enum VarType {A_inter_B, A_diff_B, B_diff_A}
      type CheckValueFuncTypeA_diff_B = (v: A_diff_B, v_id: int) => void
      type CheckValueFuncTypeB_diff_A = (v: B_diff_A, v_id: int) => void
      type CheckValueData = [
        A | B, // value
        // check value function if VarType is A_diff_B
        CheckValueFuncTypeA_diff_B | undefined,
        // check value function if VarType is B_diff_A
        CheckValueFuncTypeB_diff_A | undefined,
        VarType // value_type
      ]

      // Checks string value as value of A - B
      // that should be assignable to A_diff_B
      function check_string(v: A_diff_B) {
        arktest.assertEQ(v, "abc")
      }

      // Checks value of Cat class instance as value of B - A
      // that should be assignable to B_diff_A
      function check_Cat(v: B_diff_A) {
        if (v instanceof Cat) {
          arktest.assertEQ(v.va, 567)
          arktest.assertEQ(v.vc, 'cat')
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of Cat')
        }
      }

      // Checks value of Frog class instance as value of B - A
      // that should be assignable to B_diff_A
      function check_Frog(v: B_diff_A) {
        if (v instanceof Frog) {
          arktest.assertEQ(v.va, 567)
          arktest.assertEQ(v.vf, 5)
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of Frog')
        }
      }

      let check_values: ReadonlyArray<CheckValueData> = [
        [new Dog(), undefined, undefined, VarType.A_inter_B],
        [7.8, undefined, undefined, VarType.A_inter_B],
        ["abc", check_string, undefined, VarType.A_diff_B],
        [new Cat(), undefined, check_Cat, VarType.B_diff_A],
        [new Frog(), undefined, check_Frog, VarType.B_diff_A] ]
      const check_values_number: int = 5
    check_value_by_expression_as_type_A_diff_B:
      "arktest.assertEQ(v, \"abc\")"
    check_value_by_expression_as_type_B_diff_A:
      "arktest.assertEQ(v.va, 567)"

  - check_variant_decl_data: |-
      // A: C1 | C2 | B2 | Other
      // B: B1 | Other
      // C1<:B1
      // C2<:B1
      // C3<:B1
      // B1<:Base
      // B2<:Base

      abstract class Base {}
      abstract class B1 extends Base {vb1: int = 567}
      class B2 extends Base {vb2: bigint = 123n}
      class C1 extends B1 {vc1: int = 321}
      class C2 extends B1 {vc2: number = 6.7}
      class C3 extends B1 {vc3: float = 5.3f}
      class Other {vo: string = "other"}

      type A = C1 | C2 | B2 | Other
      type B = B1 | Other

      // type A - B is computed smart type on the negative branch
      // after branching on "v instanceof A"
      type A_diff_B = B2

      // type B - A is computed smart type on the negative branch
      // after branching on "v instanceof B"
      type B_diff_A = B1 // nearest supertype for B - A

      // VarType is type of v variable after branching on
      // "v instanceof A" and "v instanceof B"
      enum VarType {A_inter_B, A_diff_B, B_diff_A}
      type CheckValueFuncTypeA_diff_B = (v: A_diff_B, v_id: int) => void
      type CheckValueFuncTypeB_diff_A = (v: B_diff_A, v_id: int) => void
      type CheckValueData = [
        A | B, // value
        // check value function if VarType is A_diff_B
        CheckValueFuncTypeA_diff_B | undefined,
        // check value function if VarType is B_diff_A
        CheckValueFuncTypeB_diff_A | undefined,
        VarType // value_type
      ]

      // Checks value of B2 class instance as value of A - B
      // that should be assignable to A_diff_B
      function check_B2(v: A_diff_B) {
        arktest.assertEQ(v.vb2, 123n)
      }

      // Checks value of C3 class instance as value of B - A
      // that should be assignable to B_diff_A
      function check_C3(v: B_diff_A) {
        if (v instanceof C3) {
          arktest.assertEQ(v.vb1, 567)
          arktest.assertEQ(v.vc3, 5.3f)
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of C3')
        }
      }

      let check_values: ReadonlyArray<CheckValueData> = [
        [new C1(), undefined, undefined, VarType.A_inter_B],
        [new C2(), undefined, undefined, VarType.A_inter_B],
        [new Other(), undefined, undefined, VarType.A_inter_B],
        [new B2(), check_B2, undefined, VarType.A_diff_B],
        [new C3(), undefined, check_C3, VarType.B_diff_A] ]
      const check_values_number: int = 5
    check_value_by_expression_as_type_A_diff_B:
      "arktest.assertEQ(v.vb2, 123n)"
    check_value_by_expression_as_type_B_diff_A:
      "arktest.assertEQ(v.vb1, 567)"

  - check_variant_decl_data: |-
      // A: III1 | III2 | II2
      // B: II1
      // III1<:II1
      // III2<:II1
      // III3<:II1
      // C1<:III1
      // C2<:III2
      // C3<:III3
      // C4<:II2

      interface I1 {}
      interface I2 {}
      interface II1 extends I1, I2 {
        methII1() {
          return 'methII1'
        }
      }
      interface II2 extends I1, I2 {
        methII2() {
          return 'methII2'
        }
      }
      interface III1 extends II1 {}
      interface III2 extends II1 {}
      interface III3 extends II1 {}
      class C1 implements III1 {vc1: bigint = 123n}
      class C2 implements III2 {vc2: int = 321}
      class C3 implements III3 {vc3: number = 7.8}
      class C4 implements II2 {vc4: string = "abc"}

      type A = III1 | III2 | II2
      type B = II1

      // type A - B is computed smart type on the negative branch
      // after branching on "v instanceof A"
      type A_diff_B = II2

      // type B - A is computed smart type on the negative branch
      // after branching on "v instanceof B"
      type B_diff_A = II1 // nearest supertype for B - A

      // VarType is type of v variable after branching on
      // "v instanceof I1" and "v instanceof I2"
      enum VarType {A_inter_B, A_diff_B, B_diff_A}
      type CheckValueFuncTypeA_diff_B = (v: A_diff_B, v_id: int) => void
      type CheckValueFuncTypeB_diff_A = (v: B_diff_A, v_id: int) => void
      type CheckValueData = [
        A | B, // value
        // check value function if VarType is A_diff_B
        CheckValueFuncTypeA_diff_B | undefined,
        // check value function if VarType is B_diff_A
        CheckValueFuncTypeB_diff_A | undefined,
        VarType // value_type
      ]

      // Checks value of C4 class instance as value of A - B
      // that should be assignable to A_diff_B
      function check_C4(v: A_diff_B) {
        if (v instanceof C4) {
          arktest.assertEQ(v.methII2(), 'methII2')
          arktest.assertEQ(v.vc4, "abc")
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of C4')
        }
      }

      // Checks value of C3 class instance as value of B - A
      // that should be assignable to B_diff_A
      function check_C3(v: B_diff_A) {
        if (v instanceof C3) {
          arktest.assertEQ(v.methII1(), 'methII1')
          arktest.assertEQ(v.vc3, 7.8)
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of C3')
        }
      }

      let check_values: ReadonlyArray<CheckValueData> = [
        [new C1(), undefined, undefined, VarType.A_inter_B],
        [new C2(), undefined, undefined, VarType.A_inter_B],
        [new C4(), check_C4, undefined, VarType.A_diff_B],
        [new C3(), undefined, check_C3, VarType.B_diff_A] ]
      const check_values_number: int = 4
    check_value_by_expression_as_type_A_diff_B:
      "arktest.assertEQ(v.methII2(), 'methII2')"
    check_value_by_expression_as_type_B_diff_A:
      "arktest.assertEQ(v.methII1(), 'methII1')"

  - check_variant_decl_data: |-
      // A: III1 | III2 | II2
      // B: III2 | bigint
      // C1<:III1 and C1<:III2
      // C2<:II2 and C2<:III2
      // C3<:III1

      interface I {}
      interface II1 extends I {}
      interface II2 extends I {}
      interface III1 extends II1 {}
      interface III2 extends II1 {}
      class C1 implements III1, III2 {vc1: bigint = 123n}
      class C2 implements II2, III2 {vc2: int = 321}
      class C3 implements III1 {vc3: number = 7.8}

      type A = III1 | III2 | II2
      type B = III2 | bigint

      // type A - B is computed smart type on the negative branch
      // after branching on "v instanceof A"
      type A_diff_B = III1 | II2

      // type B - A is computed smart type on the negative branch
      // after branching on "v instanceof B"
      type B_diff_A = bigint

      // VarType is type of v variable after branching on
      // "v instanceof A" and "v instanceof B"
      enum VarType {A_inter_B, A_diff_B, B_diff_A}
      type CheckValueFuncTypeA_diff_B = (v: A_diff_B, v_id: int) => void
      type CheckValueFuncTypeB_diff_A = (v: B_diff_A, v_id: int) => void
      type CheckValueData = [
        A | B, // value
        // check value function if VarType is A_diff_B
        CheckValueFuncTypeA_diff_B | undefined,
        // check value function if VarType is B_diff_A
        CheckValueFuncTypeB_diff_A | undefined,
        VarType // value_type
      ]

      // Checks value of C3 class instance as value of A - B
      // that should be assignable to A_diff_B
      function check_C3(v: A_diff_B) {
        if (v instanceof C3) {
          arktest.assertEQ(v.vc3, 7.8)
        }
        else {
          arktest.assertTrue(false,
            'v should be instance of C3')
        }
      }

      // Checks bigint value as value of B - A
      // that should be assignable to B_diff_A
      function check_bigint(v: B_diff_A) {
        arktest.assertEQ(v, 3n)
      }

      // Function for skip check value of the variable by expression
      function skip_check_value_by_expression() {
      }

      let check_values: ReadonlyArray<CheckValueData> = [
        [new C1(), undefined, undefined, VarType.A_inter_B],
        [new C2(), undefined, undefined, VarType.A_inter_B],
        [new C3(), check_C3, undefined, VarType.A_diff_B],
        [3n, undefined, check_bigint, VarType.B_diff_A] ]
      const check_values_number: int = 4
    check_value_by_expression_as_type_A_diff_B:
      "skip_check_value_by_expression()"
    check_value_by_expression_as_type_B_diff_A:
      "arktest.assertEQ(v.pow(2n), 9n)"
