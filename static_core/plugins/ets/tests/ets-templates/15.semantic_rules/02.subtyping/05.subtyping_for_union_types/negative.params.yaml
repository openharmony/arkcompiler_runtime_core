# Copyright (c) 2025-2026 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

---
cases:
    - doc: |-
          Union type U (U1 | ... | Un) is a subtype of union type V (V1 | ... | Vm) if
          there is at least one type Vj (i in 1..m) for every type Ui (i in 1..n), i.e., Ui
          is a subtype of Vj (see Subtyping).
      decl: |-
          let a: string | number | boolean = 'abc'
          let b: string | number = 42
          b = a // compile-time error, boolean is absent in b
          
    - doc: |-
          Union type U (U1 | ... | Un) is a subtype of union type V (V1 | ... | Vm) if
          there is at least one type Vj (i in 1..m) for every type Ui (i in 1..n), i.e., Ui
          is a subtype of Vj (see Subtyping).
      decl: |-
          class Base {}
          class Derived extends Base {}
          
          let x: Base | string = new Base
          let y: Derived | string = 'just a test'
          y = x // compile-time error

    - doc: |-
          Non-union type T is a subtype of union type U (U1 | ... | Un) if T is assignable to a type of Ui
      decl: |-
          let u: number | string = 1 // ok
          u = "aa" // ok
          u = true // compile-time error

    - doc: |-
          unions of resizable arrays subtyping - two arrays are not related to each other
      decl: |-
          let ab: string[]|'b'[] = ['a', 'a', 'a']
          let a: 'a'[] = ['a', 'a']
          ab = a

    - doc: |-
          unions of tuples subtyping -  two tuples are not related to each other 
      decl: |-
          class A {}
          class B extends A {}
          class C {}
          let acab: [A, C]|[A, B] = [new B, new C]
          let b: [B, C] = [new B, new C]
          acab = b

    - doc: |-
          subtyping between unions
      decl: |-
          class A {}
          class B {}
          class C extends A {}
          class D extends B {}
          class E {}
          let ab: A|B = new A
          let cde: C|D|E =  new E
          ab = cde

    - doc: |-
          subtyping between unions - invariant unions
      decl: |-
          class A {}
          class B {}
          class C extends A {}
          class D extends B {}
          class E {}
          class F {}
          let abf: A|B|F = new F
          let cde: C|D|E =  new E
          abf = cde

    - doc: |-
          subtyping between unions  - invariant unions
      decl: |-
          class A {}
          class B {}
          class C extends A {}
          class D extends B {}
          class E {}
          class F {}
          let abf: A|B|F = new F
          let cde: C|D|E =  new E
          cde = abf