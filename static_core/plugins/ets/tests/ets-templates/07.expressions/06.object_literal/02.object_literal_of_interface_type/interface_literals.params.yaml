# Copyright (c) 2026 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

---
cases:
  - decl: |-
      interface I {
        a: string
        set b(b: string)
        get c(): number
      }
    type: |-
      I
    checks:
      - literal: "{a: 'a', b: 'b', c: 42}"
        field: a
        value: "'a'"
      - literal: "{a: 'a', b: 'b', c: 42}"
        field: c
        value: "42"

  - decl: |-
      interface I {
        a: string
        set b(b: string)
        get c(): number
        de?: 'd'|'e'
      }
    type: |-
      I
    checks:
      - literal: "{a: 'a', b: 'b', c: 42}"
        field: de
        value: "undefined"
      - literal: "{a: 'a', b: 'b', c: 42, de: 'd'}"
        field: de
        value: "'d'"

  - decl: |-
      interface I {
        a: string
        defaultMethod(a: string): I { this.a = a; return this }
        method(a: string): string
      }
    type: |-
      I
    checks:
      - literal: "{a: 'a', method(a: string): string { return a } }"
        field: method('a')
        value: "'a'"
      - literal: "{a: 'a', method(a: string): string { return a } }"
        field: defaultMethod('b').a
        value: "'b'"
      - literal: |- 
          {a: 'a', method(a: string): string { return a },
           defaultMethod(a: string): I { this.a = a + a; return this } }
        field: defaultMethod('b').a
        value: "'bb'"

  - decl: |-
      interface I {
        foo(d: Derived1): Base
        foo(d: Derived2): Base
      }
      class Base { b: string = "base"}
      class Derived1 extends Base { b: string  = "derived1"}
      class Derived2 extends Base { b: string  = "derived2"}
    type: |-
      I
    checks:
      # overriding method according to override-compatible sig in literal
      - literal: |- 
          {foo(d: Derived1): Derived1 { return new Derived1},
           foo(d: Derived2): Derived2 { return new Derived2}}
        field: foo(new Derived1).b
        value: "'derived1'"
      - literal: |- 
          {foo(d: Derived1): Derived1 { return new Derived1},
           foo(d: Derived2): Derived2 { return new Derived2}}
        field: foo(new Derived2).b
        value: "'derived2'"

  - decl: |-
      interface I {
        readonly a: string
        readonly b?: string
      }
    type: |-
      I
    checks:
      - literal: "{a: 'a'}"
        field: a
        value: "'a'"
      - literal: "{a: 'a'}"
        field: b
        value: "undefined"
      - literal: "{a: 'a', b: 'b'}"
        field: b
        value: "'b'"